#!/opt/perl-5.8.8/bin/perl

# Copyright 2010-2013 Andrew Leiserson <andy@leiserson.org>
# See the file README in the VP3 distribution for more information.

=head1 NAME

VP3 - Verilog preprocessor and generator

=head1 SYNOPSIS

  vp3 -y . -o module.v module.vp

=head1 DESCRIPTION

VP3 is a tool to assist in the description of a hardware design in Verilog. VP3
can generate module instantiations and signal declarations for you. It provides
a preprocessor function comparable to the C preprocessor, and allows you to
generate portions of your Verilog with embedded perl code.

VP3 works on the input in several passes. The first pass is a preprocessor. Two
preprocessors are currently supported. The built-in preprocessor is used by
default. If you specify the C<-p ep3> option, the ep3 tool will be invoked to
preprocess the source. To use the ep3 preprocessor, C<Text::EP3> must be
installed (available on CPAN).

After preprocessing is complete, VP3 parses the input, which should consist of
Verilog and VP3 directives. VP3 then performs the following translations:

=over 4

=item *

Expands C<@Instance> directives to a complete module instantiation.

=item *

Analyzes signal usage by the design and constructs a connectivity database.

=item *

Expands remaining VP3 directives. The C<@Regs> and C<@Wires> directives
generate declarations for any signals identified in the previous step that are
not otherwise declared.

=back

The core processing steps are performed on a module-by-module basis. If there
are multiple modules in the file, VP3 will process them in bottom-to-top
hierarchical order, regardless of the order they appear in the input.

After processing has completed, VP3 performs a connectivity check on the design.
Unloaded and undriven signals are flagged. Note that port inference for
unconnected signals will mask many of these connectivity errors.

=head2 Why use VP3?

=over 4

=item *

Saves tedious and error prone typing.

=item *

Instance expansion with regular expression renaming rules is more powerful than
SystemVerilog wildcard connects (.*)

=item *

Using VP3 shorthand rather than a complete verilog description reduces the
verbosity of the design description, improving maintainability

=item *

Immediate feedback about potential design issues (unconnected signals, width
mismatch, etc...) during RTL entry.

=item *

Compared to editor-based tools like Verilog-mode for Emacs, VP3 has the
advantage that it does not inflame editor holy wars and does not encourage
placing generated code under version control.

=back

=head1 OPTIONS

=over 4

=item -o file

Required. Specifies where to write the output.

=item -p preprocessor

Optional. Specifies an alternate preprocessor. The available preprocessors are
C<standard> (the default), and C<ep3>.

=item --debug

Optional. Enables additional debug output.

=item --vdefine NAME, --vdefine NAME=VALUE

Optional. Defines the Verilog preprocessor macro `NAME, either with an empty
expansion, or as VALUE.

=item --define NAME[=VALUE]

Optional. Defines the VP3 preprocessor macro NAME, either with an empty
expansion, or as VALUE.

=item --vinclude path

Optional. Specifies include paths in which to search for Verilog C<`include>
files.

=item -i path, --include path

Optional. Specifies include paths in which to search for VP3 preprocessor
C<@include> files.

=item -v file

Optional. Specifies a Verilog library file to search for instantiated modules.
Libraries specified with C<-v> must be completely read and parsed to determine
if they contain a sought module, so their use entails a performance penalty.

=item -y path

Optional. Specifies a Verilog library directory to search for instantiated
modules. The module is expected to be defined in a file named C<module.v> in one
of the specified library directories.

=item -w

Optional. Treat warnings as errors.

=back

=head1 DIRECTIVES

There are two classes of directives: preprocessor directives and VP3 directives.
By convention, preprocessor directives start with a lower case letter, and VP3
directives start with an upper case letter.

=head2 Preprocessor directives

The built-in preprocessor supports the following directives. Consult the
C<Text::EP3> documentation for information on preprocessor directives in
C<-p ep3> mode.

=over 4

=item @define NAME value

Defines C<NAME> as a preprocessor macro to be substituted with C<value>.

=item @include "file"

Includes the contents of C<file> at the current source location.

=item @perl_begin ... @perl_end

Usage:

  @perl_begin
  # any number of lines of perl code
  @perl_end

Evaluates the text between the begin/end directives as perl code.

The embedded perl code may emit text into the preprocessor output by calling
C<vprint>.

Any subroutines defined by the perl code will become available to the remainder
of the source as a directive with the same name. When invoked, the directive
subroutine will be passed a single argument containing the text (if any) on the
line, with the directive and any whitespace after the directive name removed.

=item @if

Introduces a conditional section of the source. The remainder of the line after
C<@if> is macro-expanded and then evaluated as perl code. The conditional
section continues until the next matching C<@elsif>, C<@else>, or C<@endif>
directive. Conditional sections may be nested.

=item @ifdef / @ifndef

Introduces a conditional section of the source. The remainder of the line after
the directive must consist of a single identifier. For C<@ifdef>, if that
identifier has been previously defined as a preprocessor macro, the conditional
section will be included. For C<@ifndef>, the conditional section is included if
the identifier has not been previously defined.

=item @elsif

Must be preceeded by one or more conditional directives. C<@elsif> terminates
the preceeding conditional section and introduces a new section. The section
following C<@elsif> is ignored if a previous section in the current conditional
chain has been included. Otherwise, the section following C<@elsif> is included
if the condition specified after the directive is true. C<@elsif> may be
followed either by a single identifier, in which case that identifier is tested
in the same manner as C<@ifdef>, or by a complex expression, in which case that
expression is tested in the same manner as C<@if>.

=item @else

Similar to C<@elsif>, but with an implicit true condition.

=item @endif

Ends a chain of conditional sections.

=back

=head2 VP3 directives

=over 4

=item @Module

Usage:

  @Module [-none] [-v2k] [-attr <attributes>] [module_identifier] ;

The C<@Module> directive introduces a module. If the C<module_identifier> is
not given, the module name will be taken from the name of the input file.
Except for the special case of C<@Module -none> (see below), C<@Module> should
have a corresponding C<endmodule>.

The C<@Module> directive accepts the following options:

=over 4

=item -attr <attributes>

The C<-attr> option prints the specified text as attribute(s) on the generated
module header. The string given should not include the C<(*> and C<*)>
delimeters.

=item -none

Enter module context, but don't generate any C<module> statement. This may be
useful to generate files to be inserted in other source using C<`include>. When
C<@Module -none> is used, do not use C<endmodule>. In this mode, connectivity
validation is disabled.

=item -v2k

The C<-v2k> option causes the generated module header to use the Verilog-2001
syntax, which has full port declarations inline with the header. For more
detail, see below.

=back

The C<@Module> directive is useful when using VP3's optional port inference
function, which automatically creates port declarations for signals that are
undriven or unloaded in the input module description:

=over 4

=item *

For Verilog-1995-style module headers, use the C<@Module> directive (without
the C<-v2k> option) regardless of whether inferred ports are desired. If
inferred ports are desired, specify the C<@Ports> directive within the module.
Whether or not port inference is enabled, VP3 will scan the module definition
for C<input> and C<output> declarations, and C<@Module> will include
identifiers found in those declarations in the generated port list. If
C<@Ports> is specified in the module, C<@Module> will also include the names of
any inferred ports in the generated port list.

=item *

For Verilog-2001-style module headers, use C<@Module -v2k> if and only if port
inference is desired. When using inferred ports, signals may be explicitly
declared as I/O with the C<@Input> and C<@Output> directives. If port inference
is not desired, do not use the C<@Module> directive. Code the module header
directly in Verilog syntax.

=back

=item @Ports

Usage:

  @Ports;

The C<@Ports> directive generates Verilog-1995 port declarations for any
signals used in the module that are undriven or unloaded. An input or output
port will be defined, as applicable.

When using Verilog-2001 module headers, inferred ports are generated directly
in the module header by C<@Module>. C<@Ports> should not be used.

=item @Regs, @Wires

Usage:

  @Regs;
  @Wires;

These directives generate signal declarations for signals that are used in the
source but are not otherwise declared. The type of declaration is inferred
automatically based on usage.

=item @Input, @Output

Usage:

  @Input signal_identifier;
  @Output signal_identifier;

These directives force a signal to be declared as an input or output even if it
would not normally be inferred as such. A typical usage is a signal that is used
locally within the module but is also required in other modules. The local usage
of the signal would normally prevent automatic output port declaration.

These directives should be used only when ports are being inferred with
C<@Ports> or C<@Module -v2k>. Otherwise, the desired port declarations should be
coded explicitly.

=item @Waive

Usage:

  @Waive no_source signal_identifier;
  @Waive no_sink signal_identifier;

The C<@Waive> directive inhibits connectivity errors for the specified signals.

=item @Vector

Usage:

  @Vector expression signal_identifier;

  @Vector [msb:lsb] signal_identifier;

The C<@Vector> directive specifies the size of the specified signal. The size
will be used in any autogenerated declarations for that signal. The size may be
specified as a single number, in which case the signal range will be
[size-1:0], or the range may be specified directly.

=item @Unparsed

Usage:

  @Unparsed begin;
  // unsupported Verilog constructs
  @Unparsed end;

The C<@Unparsed> directive provides a means to pass through Verilog constructs
that are not yet supported by the VP3 parser. It can also be used around code
that should not be processed by VP3 for some other reason. The text between the
directives will be included verbatim in the output. No connectivity analysis or
VP3 directive expansion will be performed on the unparsed section.

=item @Instance

Usage:

  @Instance [-file instance.v] instance instance_name
    -connect instance_portA     connectionA
    -connect instance_portB     connectionB
    -connect /^instance_prefix/ connection_prefix
  ;

The C<@Instance> directive expands as an instantiation of the specified module.
The source of the instantiated module must either be located in one of the
search locations specified on the command line or be specified with the C<-file>
option.

By default, ports of the instantiated module will be connected to like-named
signals in the current module. The connection can be modified with C<-connect>
options. The first argument after C<-connect> is a pattern to match against the
ports of the instantiated module, and the second argument is replacement text.
If the pattern is not delimited by slashes, it must match the full port name
(C<^> and C<$> are implicitly added to the pattern). If the pattern is delimited
by slashes, it may match any part of the port name, and the replacement will be
applied only to the matching part.

=back

=head1 PERL FUNCTIONS

VP3 provides some functions which may be used by user Perl code running in
C<@perl_begin>/C<@perl_end> sections.

=over 4

=item vexpr

Usage:

  vexpr ("verilog expression")

Example:

  vexpr ("2 + 2")
  // Returns 4

The C<vexpr> function allows user code to call VP3's expression evaluation
engine.

=item vports

Usage:

  vports ("module")

The C<vports> function searches for the specified module using the same search
locations that would be used for a C<@Instance> directive, parses it, and
returns a list of the ports of the module. The return value is a C<VP3::Ports>
object.

=item vprint

Usage:

  vprint (list)

This function prints the provided arguments into the intermediate Verilog. Text
inserted in will be seen by the later phases of VP3 processing. This means that
it is possible to emit, for example, VP3 C<@Instance> directives.

This function is provided only under the built-in preprocessor. When using the
ep3 preprocessor, C<print> should be used instead. The built-in preprocessor
preserves C<print> as a means of printing text to the console.

=back

=head1 BUGS

This is alpha-quality software and bugs are to be expected. Please report bugs
in the issue tracker on github.

The following Verilog constructs are not yet supported:

=over 4

=item *

specify blocks

=item *

primitives (gates and UDPs)

=item *

text macros with arguments

=item *

preprocessor directives other than `timescale, `include, `define, `undef, and
`line

=item *

ports connected by order (accepted by the parser but not understood for
connectivity analysis)

=item *

complex ports (all the examples other than C<module test> in section 12.3.3 of
the standard)

=item *

instance arrays

=item *

generate blocks (accepted by the parser but not otherwise handled)

=item *

big-endian vectors

=item *

port connection attributes, and some other attribute uses that are (I hope)
esoteric

=back

=head1 AUTHOR

Andrew Leiserson <andy@leiserson.org>

=cut

# The following features from recent perls are used:
# * lvalue subroutines (5.6)
# * open scalar as a filehandle a la istrstream (5.8 / PerlIO)

use 5.008;

use strict;
use warnings FATAL => qw(all);

# Note that a version with one dot ("0.x") is treated as 0.x00 whereas a
# version with two dots ("0.x.y") is treated as 0.00x00y
our ($VERSION) = "0.1.64";

######################################################################

# This routine requires a clean lexical environment
sub VP3::Preprocessor::standard::_eval
{
    eval "package $_[0]->{pkg_name}; $_[1]";
}

######################################################################

{

    package VP3::ParseTreeVisitor;

    # Abstract base class for parse tree visitors

    no warnings 'recursion';

    sub new
    {
        my ($class, $default) = @_;

        my $self = {
            target_stack => [],
        };

        bless $self, $class;

        $default ||= $self->can ("visit_children");
        $self->{default} = $default;

        $self;
    }

    sub debug
    {
        $_[0]->{debug} = $_[1];
    }

    sub visit
    {
        my ($self, $target) = @_;

        print STDERR "visit ", $target->type, "\n" if $self->{debug};

        goto $self->can ("visit_" . $target->type) ||
             $self->{default};
    }

    sub visit_children
    {
        my ($self, $target) = @_;

        $self->push_target ($target);

        for (@{$target->children}) {
            $self->visit ($_);
        }

        $self->pop_target;
    }

    # target_stack only used for debugging?
    sub push_target
    {
        push @{$_[0]->{target_stack}}, $_[1];
    }

    sub pop_target
    {
        pop @{$_[0]->{target_stack}};
    }

    sub dump_targets
    {
        print scalar @{$_[0]->{target_stack}};
        join "", map { $_->type . " `" . substr ($_->emit_self, 0, 60) . "'\n" } @{$_[0]->{target_stack}};
    }

} # package VP3::ParseTreeVisitor

{

    package VP3::ParseTreeMutator;
    use base 'VP3::ParseTreeVisitor';

    no warnings 'recursion';

    sub visit
    {
        $_[0]->{debug} && print STDERR "visit ", $_[1]->type, "\n";

        goto $_[0]->can ("visit_" . $_[1]->type) ||
             $_[0]->{default};
    }

    sub visit_children
    {
        my @result;

        for (@{$_[1]->children}) {
            push @result, $_[0]->visit ($_);
        }

        @{$_[1]->children} = @result;

        $_[1];
    }

    sub parse
    {
        my ($self, $mode, $text, $error_ref) = @_;

        my $p = VP3::Parser->new;
        $p->scope (VP3::ParseTree->factory ("module_declaration"));
        $p->YYData->{lexer} = VP3::Lexer->new ($mode);

        open (my $fh, "<", \$text)
            or VP3::fatal ("unable to open string as a filehandle: $!");
        $p->YYData->{lexer}->input ($fh, undef);

        $p->YYParse (
                     yylex   => sub { $_[0]->YYData->{lexer}->lex (@_[1..$#_]) },
                     yyerror => \&VP3::Parser::default_yyerror,
                    )
            or ($$error_ref = $p->YYData->{error}, undef);
    }

} # package VP3::ParseTreeMutator

{
    package VP3::Symtab;

    use Carp;

    sub new
    {
        my ($class) = $_[0];
        return bless { }, $class;
    }

    sub insert
    {
        my ($self, $sym, $val) = @_;

        exists $self->{table}{sym} and croak "Attempt to redefine $sym";

        #$val && ref ($val) eq "VP3::Symbol" or croak "Argument to VP3::Symtab::insert must be a VP3::Symbol";
        if ($val && ref ($val) ne "VP3::Symbol") {
            # !!! fix users of this form
            $self->{table}{$sym} = VP3::Symbol->new ($val);
        } else {
            $self->{table}{$sym} = $val;
        }

        $self->{table}{$sym};
    }

    sub lookup
    {
        my ($self, $sym) = @_;

        $self->{table}{$sym};
    }

} # package VP3::Symtab;

{
    package VP3::Symbol;

    # This should be improved. Currently the "data" member is only used for
    # parameters, to store the definition in case the parameter needs to be
    # evaluated.

    sub new
    {
        my ($class, $type, $data) = @_;
        return bless { type => $type, data => $data }, $class;
    }

    sub type : lvalue { $_[0]->{type} }
    sub data : lvalue { $_[0]->{data} }

} # package VP3::Symbol

{

    package VP3::ConnectivityAnalyzer;
    use base 'VP3::ParseTreeVisitor';

    #use VP3::Errors;
    #VP3::Errors->import;

    use Carp;
    use Data::Dumper;

    # Main entry point.
    # static method
    sub analyze
    {
        my ($vp3, $module) = @_;

        $module->typeis ("module_declaration")
            or confess "usage: VP3::ConnectivityAnalyzer->analyze (<module_declaration obj>)";

        my $obj = __PACKAGE__->new ($vp3, $module);
        $obj->visit ($module);
        $obj->result;
    }

    sub new
    {
        my ($class, $vp3, $module) = @_;
        my $self = $class->SUPER::new;
        $self->{vp3}           = $vp3;
        $self->{module}        = $module;
        $self->{direction}     = "sink";
        $self->{source_type}   = undef;
        $self->{inst_ports}    = undef;
        $self->{db}            = VP3::ConnectivityDB->new;
        bless $self, $class;
    }

    sub result { $_[0]->{db}; }

    # Utilities

    sub ignore { }

    # Element-specific visit methods

    {
        #no strict 'refs';
        no warnings qw(once);

        # Portions of the source that we can ignore entirely
        *visit_list_of_port_identifiers = \&ignore;
        *visit_list_of_variable_port_identifiers = \&ignore;
        *visit_inout_declaration    = \&ignore;
        *visit_reg_declaration      = \&ignore;
        *visit_integer_declaration  = \&ignore;
        *visit_real_declaration     = \&ignore;
        *visit_time_declaration     = \&ignore;
        *visit_realtime_declaration = \&ignore;
        *visit_event_declaration    = \&ignore;
        *visit_genvar_declaration   = \&ignore;

        *visit_parameter_override   = \&ignore;

        *visit_generated_instantiation = \&ignore;

        # !!! Probably these need to be considered in some form
        *visit_function_declaration = \&ignore;
        *visit_task_declaration     = \&ignore;
    }

    sub visit_module_declaration
    {
        my ($self, $target) = @_;
        my $conn;

        #print "Visiting module ", $target->module_identifier, "\n";

        $self->visit ($target->port_list);
        $self->visit ($target->module_items);
    }

    sub visit_assignment
    {
        my ($self, $target) = @_;

        if ($target->assignment_type eq "continuous") {
            $self->{source_type} = "net";
        } elsif ($target->assignment_type eq "blocking" ||
                 $target->assignment_type eq "nonblocking") {
            $self->{source_type} = "variable";
        } else {
            VP3::fatal ("Unknown assignment type $target->assignment_type");
        }

        $self->push_target ($target);

        $self->{direction} = "source";
        $self->visit ($target->lhs);

        $self->{direction} = "sink";
        $self->visit ($target->rhs);

        #$self->{direction} = undef;

        $self->{source_type} = undef;

        $self->pop_target;
    }

    sub visit_net_declaration
    {
        my ($self, $target) = @_;

        if ($target->list->typeis ("list_of_net_decl_assignments")) {
            $self->visit ($target->list);
        }
    }

    sub visit_input_declaration
    {
        my ($self, $target) = @_;

        for ($target->port_names) {
            my $conn = VP3::Connectivity->new ($target->line, "input", "source");
            $self->{db}->signal ($_)->add_connectivity ($conn);
        }
    }

    sub visit_output_declaration
    {
        my ($self, $target) = @_;

        for ($target->port_names) {
            my $conn = VP3::Connectivity->new ($target->line, "output", "sink");
            $self->{db}->signal ($_)->add_connectivity ($conn);
        }
    }

    sub visit_identifier
    {
        my ($self, $target) = @_;

        my $ident = $target->emit_self;
        # !!! shouldn't assume the module is the scope, need to push/pop scopes
        # as we go (assumed scope)
        my $sym   = $self->{module}->symtab->lookup ($ident);
        $sym && $sym->type eq "parameter" and return;

        # TODO be more careful and enable this error check

        # state [0]: sink type (net, variable; previously always, instance)
        # state [1]: direction (source, sink)
        #ref ($self->{state}) eq "ARRAY"
        #    or confess "Internal error. \$self->{state} = " . Dumper ($self->{state});

        #defined ($self->{state}[0]) && defined ($self->{state}[1])
        #    or die "Internal error\n" . $self->dump_targets;

        my $conn = VP3::Connectivity->new ($target->line, $self->{source_type}, $self->{direction});
        $self->{db}->signal ($ident)->add_connectivity ($conn);
    }

    sub visit_hierarchical_identifier
    {
        # Connectivity of hierarchical references not processed
        return;
    }

    sub visit_identifier_subscripts
    {
        my ($self, $target) = @_;

        #print $target->type, "\n";
        #print $target->emit, "\n";
        #print $target->identifier->type, "\n";

        if ($target->identifier->typeis ("hierarchical_identifier")) {
            # Connectivity of hierarchical references not processed
            return;
        }

        # parameters don't generate connectivity
        my $ident = $target->identifier->emit_self;
        # !!! assumed scope
        my $sym  = $self->{module}->symtab->lookup ($ident);
        $sym && $sym->type eq "parameter" and return;

        my $subscripts = $target->subscripts->children;

        # MDAs connectivity is not processed
        if (@$subscripts > 1) {
            return;
        }

        my $conn = VP3::Connectivity->new ($target->line, $self->{source_type}, $self->{direction});

        # We bailed if there are multiple subscripts, so this is the same as [0]
        my $range = $subscripts->[-1];

        #print STDERR "working on $ident: " . $range->emit_self . " (" . $range->type . ")\n";

        # duplicates visit_named_port_connection
        if ($range->typeis ("unsigned_number")) {
            my $bit = VP3::Expression::evaluate ($self->{module}, $range); # !!! assumed scope
            $bit =~ /^\d+$/ or die "Unsupported complex expression in range: $bit"; # !!!
            $conn->msb ($bit);
            $conn->lsb ($bit);
        } elsif ($range->typeis ("range_expression_colon")) {
            # MSB:LSB range specification

            my $msb = $range->evaluate_msb ($self->{module}); # !!! assumed scope
            my $lsb = $range->evaluate_lsb ($self->{module}); # !!! assumed scope

            $conn->msb ($msb);
            $conn->lsb ($lsb);
        } elsif ($range->typeis ("identifier") || $range->typeis ("identifier_subscripts")) {
            my $saved_source_type = $self->{source_type};
            my $saved_direction   = $self->{direction};

            $self->{source_type} = undef;
            $self->{direction}   = "sink";

            $self->visit ($range);

            $self->{source_type} = $saved_source_type;
            $self->{direction}   = $saved_direction;
        } else {
            #die "Unknown or unsupported range_expression type " . $range->type . "\n" . Dumper ($range);
            # !!!
        }

        $self->{db}->signal ($ident)->add_connectivity ($conn);
    }

    sub visit_conditional_statement
    {
        my ($self, $target) = @_;

        $self->push_target ($target);

        #$self->{direction} = "sink";
        $self->visit ($target->expr);
        #$self->{direction} = undef;

        $self->visit ($target->statement);
        $self->visit ($target->opt_else);

        $self->pop_target;
    }

    sub visit_case_statement
    {
        my ($self, $target) = @_;

        $self->push_target ($target);

        #$self->{direction} = "sink";
        $self->visit ($target->expr);
        #$self->{direction} = undef;

        $self->visit ($target->items);

        $self->pop_target;
    }

    sub visit_module_instantiation
    {
        my ($self, $target) = @_;

        my $inst_module = $target->module_identifier->emit_self;

        my $ports = $self->{vp3}->ports ($inst_module);

        # !!! should we fail if we don't get the ports?

        if ($ports) {
            $self->{source_type}  = "net";
            $self->{inst_ports}   = $ports;
            $self->{inst_module}  = $inst_module;

            $self->visit ($target->module_instances);

            $self->{source_type}  = undef;
            $self->{inst_ports}   = undef;
            $self->{inst_module}  = undef;
        }
    }

    sub visit_module_instance
    {
        my ($self, $target) = @_;
        $self->visit ($target->list_of_port_connections);
    }

    sub visit_named_port_connection
    {
        my ($self, $target) = @_;

        my $ident = $target->port_identifier->emit_self;

        if (!exists $self->{inst_ports}{$ident}) {
            VP3::error ($target->location . ": port `$ident' not found in module `$self->{inst_module}'",
                        "module `$self->{inst_module}' defined at " . $self->{inst_ports}->location);
            return;
        }

        # Check connection widths
        if ($target->expression->typeis ("identifier_subscripts")) {
            my $identifier_subscripts = $target->expression;
            #print STDERR "Checking expression widths for $ident\n";

            my $range = $identifier_subscripts->subscripts->children->[-1];
            my $loconn_msb = $self->{inst_ports}{$ident}{msb};
            my $loconn_lsb = $self->{inst_ports}{$ident}{lsb};

            if ($range->typeis ("unsigned_number")) {
                # Single bit range specification

                my $bit = VP3::Expression::evaluate ($self->{module}, $range); # !!! assumed scope
                $bit =~ /^\d+$/ or die "Unsupported complex expression in range: $bit"; # !!!
                if (!defined ($loconn_msb)) {
                    # single-bit vector connected to scalar, this is ok
                } elsif ($loconn_msb != $loconn_lsb) {
                    VP3::warning ($target->location . ": range mismatch in connection for port `$ident'",
                                  "range in $self->{inst_module} is [$loconn_msb:$loconn_lsb]",
                                  "connected to $identifier_subscripts->identifier with range [$bit]");
                }

            } elsif ($range->typeis ("range_expression_colon")) {
                # MSB:LSB range specification

                my $hiconn_msb = $range->evaluate_msb ($self->{module}); # !!! assumed scope
                my $hiconn_lsb = $range->evaluate_lsb ($self->{module}); # !!! assumed scope

                defined ($hiconn_msb) && defined ($loconn_msb) && defined ($hiconn_lsb) && defined ($loconn_lsb)
                    or do { no warnings 'uninitialized'; die "Undefined range value in connection of `$ident', hiconn $hiconn_msb:$hiconn_lsb, loconn $loconn_msb:$loconn_lsb"; }; # !!!

                my $hiconn_width = $hiconn_msb >= $hiconn_lsb ? $hiconn_msb - $hiconn_lsb + 1 : $hiconn_lsb - $hiconn_msb + 1;
                my $loconn_width = $loconn_msb >= $loconn_lsb ? $loconn_msb - $loconn_lsb + 1 : $loconn_lsb - $loconn_msb + 1;

                if ($hiconn_width != $loconn_width) {
                    VP3::warning ($target->location . ": range mismatch in connection for port `$ident'",
                                  "range in $self->{inst_module} is [$loconn_msb:$loconn_lsb]",
                                  "connected to " . $identifier_subscripts->identifier->emit_self . " with range [$hiconn_msb:$hiconn_lsb]");
                }

            } else {
                die "Unknown or unsupported range_expression type " . $range->type . "\n" . Dumper ($range);
            }

        }

        # source_type is set to net by visit_module_instantiation

        if ($self->{inst_ports}{$ident}{dir} == &VP3::Port::DIR_INPUT) {
            #$self->{direction} = "sink";
            $self->visit ($target->expression);
        } elsif ($self->{inst_ports}{$ident}{dir} == &VP3::Port::DIR_OUTPUT) {
            $self->{direction} = "source";
            $self->visit ($target->expression);
            $self->{direction} = "sink";
        } else {
            # Internal error
            VP3::fatal ("Unknown port direction `" . $self->{inst_ports}{$ident}{dir} . "'");
        }
    }

    sub visit_task_enable
    {
        my ($self, $target) = @_;

        if ($target->identifier->is_system_identifier) {
            return;
        } else {
            $self->visit ($target->opt_arguments);
        }
    }

    sub visit_function_call
    {
        my ($self, $target) = @_;

        if ($target->identifier->is_system_identifier) {
            return;
        } else {
            $self->visit ($target->arguments);
        }
    }

    sub visit_vp3_vector_directive
    {
        my ($self, $target) = @_;

        my $signal = $self->{db}->signal ($target->identifier->emit_self);

        if ($target->width->typeis ("range")) {
            my $msb = VP3::Expression::evaluate ($self->{module}, $target->width->msb);
            my $lsb = VP3::Expression::evaluate ($self->{module}, $target->width->lsb);
            $signal->update_msb ($msb);
            $signal->update_lsb ($lsb);
        } else {
            my $width = VP3::Expression::evaluate ($self->{module}, $target->width);
            $signal->set_width ($width);
        }
    }

    sub visit_vp3_force_directive
    {
        my ($self, $target) = @_;

        $self->{db}->signal ($target->identifier->emit_self)
            ->set_force_type ($target->force_type);
    }

    sub visit_vp3_waive_directive
    {
        my ($self, $target) = @_;

        my $waiver_type = $target->waiver_type;

        if (!exists ({
                        "no_source" => 1,
                        "no_sink"   => 1,
                     }->{$waiver_type})) {
            VP3::error ("Bad waiver type $waiver_type");
            return;
        }

        push @{$self->{db}{waivers}{$waiver_type}}, $target->identifier;
    }

} # package VP3::ConnectivityAnalyzer

{
    package VP3::Expression;

    #use Data::Dumper;

    # class method
    sub evaluate
    {
        my ($scope, $expr) = @_;

        goto __PACKAGE__->can ("eval_" . $expr->type) ||
             sub { VP3::error ("Evaluation of an expression of type `" . $_[1]->type . "' is not supported"); undef };
    }

    sub eval_identifier
    {
        my ($scope, $ident_obj) = @_;

        my $ident = $ident_obj->emit_self;

        my $sym = $scope->symtab->lookup ($ident);

        #print Dumper ({ ident => $ident, sym => $sym });

        if ($sym && $sym->type eq "parameter") {
            return evaluate ($scope, $sym->data);
        } else {
            VP3::warning ($ident_obj->location . ": unable to evaluate `$ident'");
            return undef;
        }

    }

    sub eval_unsigned_number
    {
        my $value = $_[1]->emit_self;

        $value =~ tr/_//d;

        # Could check against /\d+/ at this point, but that's the definition of
        # an unsigned_number in the lexer, so hopefully not necessary

        $value;
    }

    sub eval_based_number
    {
        my $bn = $_[1];

        my $base = $bn->base;
        my $value = $bn->value;
        $value =~ tr/_//d;

        if ($base eq 'd') {
            return $value;
        } elsif ($base eq 'o') {
            return oct ($value);
        } elsif ($base eq 'h') {
            return hex ($value);
        } elsif ($base eq 'b') {
            return unpack ("V", pack ("b32", scalar (reverse ($value))));
        } else {
            VP3::error ("illegal radix " . $base . " in based_number");
        }
    }

    sub eval_binary_operator_expression
    {
        my ($scope, $binop) = @_;

        my $lval = evaluate ($scope, $binop->left);
        my $rval = evaluate ($scope, $binop->right);

        defined ($lval) && defined ($rval) or return undef;

        my $op = $binop->op;

        $op eq '+' && return $lval + $rval;
        $op eq '-' && return $lval - $rval;
        $op eq '*' && return $lval * $rval;

        die "Binary op $op not supported for expression evaluation";
    }

} # package VP3::Expression

{

    package VP3::Signal;

    sub new
    {
        my ($class, $identifier) = @_;
        my $self = {
            identifier      => $identifier,
            connectivity    => [ ],
            force_type      => "",
        };
        return bless $self, $class;
    }

    sub add_connectivity
    {
        my ($self, $conn) = @_;

        defined ($conn->msb) and $self->update_msb ($conn->msb);
        defined ($conn->lsb) and $self->update_lsb ($conn->lsb);

        push @{$self->{connectivity}}, $conn;
    }

    sub connectivity
    {
        return @{$_[0]->{connectivity}};
    }

    sub identifier
    {
        $_[0]->{identifier};
    }

    # !!! very primitive
    sub set_width
    {
        $_[0]->{msb} = $_[1] - 1;
        $_[0]->{lsb} = 0;
    }

    sub width
    {
        $_[0]->{msb} - $_[0]->{lsb} + 1;
    }

    # Not right for big-endian vectors !!!
    sub update_lsb
    {
        my ($self, $new_lsb) = @_;

        #print STDERR "update_lsb $self->{identifier} $new_lsb\n";
        if (!defined ($self->{lsb}) || $new_lsb < $self->{lsb}) {
            $self->{lsb} = $new_lsb;
        }
    }

    sub update_msb
    {
        my ($self, $new_msb) = @_;

        #print STDERR "update_msb $self->{identifier} $new_msb\n";
        if (!defined ($self->{msb}) || $new_msb > $self->{msb}) {
            $self->{msb} = $new_msb;
        }
    }

    sub set_force_type
    {
        $_[0]->{force_type} = $_[1];
    }

    sub force_type
    {
        $_[0]->{force_type};
    }

    sub declaration
    {
        if ($_[1]) {
            if ($_[0]->{declaration}) {
                die "Attempt to redefine " . $_[0]->identifier;
            }

            $_[0]->{declaration} = $_[1];
        }

        $_[0]->{declaration};
    }

    sub sources { grep { $_->{direction} eq "source" } @{$_[0]->{connectivity}}; }
    sub sinks   { grep { $_->{direction} eq "sink"   } @{$_[0]->{connectivity}}; }

    sub input_connection  { grep { $_->{type} && $_->{type} eq "input"  } @{$_[0]->{connectivity}}; }
    sub output_connection { grep { $_->{type} && $_->{type} eq "output" } @{$_[0]->{connectivity}}; }

    # Returns the type that this signal should be declared as, based on usage.
    # "input", "output", "reg", "wire"
    sub implicit_declaration_type
    {
        my ($self) = @_;
        my ($input, $output, $reg, $wire);

        if ($self->{force_type} eq "input") {
            $input = 1;
        } elsif ($self->{force_type} eq "output") {
            $output = 1;
        } elsif ($self->{force_type}) {
            die "Unknown forced declaration type: $self->{force_type}";
        } elsif (0 == $self->sources) {
            $input = 1;
        } elsif (0 == $self->sinks) {
            $output = 1;
        }

        if (grep { $_->{direction} eq "source" && $_->{type} eq "variable" } @{$self->{connectivity}}) {
            $reg = 1;
        }

        # !!! For now declare all wires, even signals also declared as input/output. Review.
        #if (!$input && !$output && !$reg) {
        if (!$reg) {
            $wire = 1;
        }

        (input => $input, output => $output, reg => $reg, wire => $wire);
    }

    # Returns the width that this signal should be declared with, if known
    sub implicit_declaration_range
    {
        my ($self) = @_;

        if (defined ($self->{msb})) {
            return "[$self->{msb}:$self->{lsb}]";
        } else {
            return "";
        }
    }

} # package VP3::Signal

{

    package VP3::Connectivity;

    use Carp;

    sub new
    {
        my ($class, $location, $type, $direction) = @_;

        $direction or confess ("Must specify connection direction");
        if ($direction eq "source") {
            $type or confess ("Must specify connection type for source connections");
        }

        my $self = {
            location    => $location,
            type        => $type,
            direction   => $direction,
        };
        return bless $self, $class;
    }

    # Not right for big-endian vectors !!!
    sub lsb
    {
        my ($self, $new_lsb) = @_;

        defined ($new_lsb) and $self->{lsb} = $new_lsb;

        $self->{lsb};
    }

    sub msb
    {
        my ($self, $new_msb) = @_;

        defined ($new_msb) and $self->{msb} = $new_msb;

        $self->{msb};
    }

} # package VP3::Connectivity

{

    package VP3::ConnectivityDB;

    #use VP3::Errors;
    #VP3::Errors->import;

    sub new
    {
        my ($class) = @_;
        my $self = {
            signals => { },
            waivers => { no_source => [ ], no_sink => [ ], },
        };
        bless $self, $class;
    }

    sub db_each
    {
        # Need to force list context
        (each %{$_[0]->{signals}});
    }

    sub signals
    {
        return keys %{$_[0]->{signals}};
    }

    sub signal
    {
        my ($self, $signal) = @_;
        return $self->{signals}{$signal} ||= VP3::Signal->new ($signal);
    }

    sub sourceless
    {
        grep { 0 == $_->sources } values %{$_[0]->{signals}};
    }

    sub sinkless
    {
        grep { 0 == $_->sinks } values %{$_[0]->{signals}};
    }

    # Check for unwaived sourceless and sinkless signals
    sub validate
    {
        my $self = shift;

        my @sourceless = $self->sourceless;
        my @sinkless = $self->sinkless;

        for my $sig (sort { $a->identifier cmp $b->identifier } @sourceless) {
            unless (grep { $_ eq $sig->identifier } @{$self->{waivers}{no_source}}) {
                VP3::warning ("Signal " . $sig->identifier . " has no source");
            }
        }

        for my $sig (sort { $a->identifier cmp $b->identifier } @sinkless) {
            unless (grep { $_ eq $sig->identifier } @{$self->{waivers}{no_sink}}) {
                VP3::warning ("Signal " . $sig->identifier . " has no sink");
            }
        }
    }

} # package VP3::ConnectivityDB

{
    package VP3::Port;

    use constant {
        DIR_INPUT  => 1,
        DIR_OUTPUT => 2,
        DIR_INOUT  => 3,
    };

    sub new
    {
        my ($class) = shift;
        my $self = { @_ };
        bless $self, $class;
    }

} # package VP3::Port

{

    # This class exists to preserve ordering of port collections. Tie::IxHash
    # or similar could also be used but isn't part of the core perl
    # distribution. Calls to `keys' and `values' on VP3::Ports objects have
    # been cleaned, but the code does perform direct lookups into the hash.
    # Any class variables should be prefixed with ! to avoid possible
    # collisions with verilog identifiers. Removal from the port collection is
    # not supported.

    package VP3::Ports;

    sub new
    {
        my ($class) = @_;
        my $self = { '!list' => [ ] };
        bless $self, $class;
    }

    sub location
    {
        defined ($_[1]) and $_[0]->{'!location'} = $_[1];
        $_[0]->{'!location'};
    }

    sub add
    {
        my ($self, $port) = @_;
        push @{$self->{'!list'}}, $port;
        $self->{$port->{name}} = $port;
    }

    sub all_ports { $_[0]->{'!list'}; }

} # package VP3::Ports

######################################################################

# ParseTree classes

{

    package VP3::ParseTree;

    use Scalar::Util qw(blessed);
    use Data::Dumper;
    use File::Spec;
    use Carp;

    use constant {
        VISIBLE_ONLY => 1,
    };

    # Usage 1: x->new (node type, [ child nodes ])
    # Usage 2: x->new (node type, "node contents")
    sub new
    {
        my ($class, $type) = (shift, shift);
        my $text_self = "";

        if ($#_ == 0 && !ref ($_[0])) {
            # Node with text contents
            croak "Missing node contents" unless defined $_[0];
            $text_self = $_[0];
            @_ = ();
        } elsif (@_ == grep { blessed ($_) && $_->isa ("VP3::ParseTree") } @_) {
            # Node with children, or empty
        } else {
            croak "Invalid arguments to " . __PACKAGE__ . "::new:\n" . Dumper (@_);
        }

        my $self = {
            front       => [ ],
            text_self   => $text_self,
            back        => [ ],
            children    => [ @_ ],
            visible     => 1,
        };

        return bless $self, $class;

    }

    sub factory
    {
        shift if $_[0] eq "VP3::ParseTree";
        my $type = shift;

        !ref ($type) && $type
            or croak "Must pass node type as first argument to VP3::ParseTree::factory\n";

        if ("VP3::ParseTree::$type"->can ("new")) {
            return "VP3::ParseTree::$type"->new ($type, @_);
        } else {
            return VP3::ParseTree::generic->new ($type, @_);
        }
    }

    sub type
    {
        my $txt = ref ($_[0]);
        $txt =~ s/^VP3::ParseTree:://;
        $txt;
    }

    sub typeis
    {
        return $_[0]->isa ("VP3::ParseTree::$_[1]");
    }

    sub line
    {
        defined ($_[1]) and $_[0]->{source_line} = $_[1];
        $_[0]->{source_line};
    }

    {
        no warnings 'once';
        *source_line = \&line;
    }

    sub source_file
    {
        defined ($_[1]) and $_[0]->{source_file} = $_[1];
        $_[0]->{source_file};
    }

    sub location
    {
        if (@{$_[0]->{children}}) {
            $_[0]->{children}->[0]->location;
        } else {
            my ($file, $line);

            $file = $_[0]->{source_file};
            $line = $_[0]->{source_line};

            if (defined $file) {
                $file = File::Spec->canonpath ($file);
            } else {
                $file = "<unknown file>";
            }

            $line = "<unknown line>" unless defined $line;

            return "$file:$line";
        }
    }

    # Set the location of this node and all children. Applied to
    # internally-generated verilog parsed out of strings.
    sub location_set_recursive
    {
        if (@{$_[0]->{children}}) {
            $_->location_set_recursive ($_[1], $_[2]) for @{$_[0]->{children}};
        } else {
            $_[0]->source_file ($_[1]);
            $_[0]->source_line ($_[2]);
        }
    }

    sub visible
    {
        defined ($_[1]) and $_[0]->{visible} = $_[1];
        $_[0]->{visible};
    }

    sub text_self { $_[0]->{text_self} = $_[1]; }

    sub prepend_text
    {
        if (ref $_[1]) {
            #carp ("prepend_text called with ref argument");
            $_[0]->prepend ($_[1]);
        } else {
            my $txt = $_[1];

            if (@{$_[0]->{children}}) {
                $_[0]->{children}->[0]->prepend_text ($txt);
            } else {
                croak "Missing node contents" unless defined $txt;
                unshift @{$_[0]->{front}}, VP3::ParseTree->factory ("whitespace", $txt);
            }
        }

        $_[0];
    }

    sub prepend
    {
        return $_[0] if $_[1]->type eq "null";

        if (@{$_[0]->{children}}) {
            $_[0]->{children}->[0]->prepend ($_[1]);
        } else {
            my $front = $_[1]->{front};
            my $back  = $_[1]->{back};
            $_[1]->{front} = [ ];
            $_[1]->{back}  = [ ];

            $_[0]->prepend ($_) for @{$back};
            unshift @{$_[0]->{front}}, $_[1];
            $_[0]->prepend ($_) for @{$front};
        }

        $_[0];
    }

    sub append_text
    {
        if (ref $_[1]) {
            #carp ("append_text called with ref argument");
            $_[0]->append ($_[1]);
        } else {
            my $txt = $_[1];

            if (@{$_[0]->{children}}) {
                $_[0]->{children}->[-1]->append_text ($txt);
            } else {
                croak "Missing node contents" unless defined $txt;
                push @{$_[0]->{back}}, VP3::ParseTree->factory ("whitespace", $txt);
            }
        }

        $_[0];
    }

    sub append
    {
        return $_[0] if $_[1]->type eq "null";

        if (@{$_[0]->{children}}) {
            $_[0]->{children}->[-1]->append ($_[1]);
        } else {
            my $front = $_[1]->{front};
            my $back  = $_[1]->{back};
            $_[1]->{front} = [ ];
            $_[1]->{back}  = [ ];

            $_[0]->append ($_) for @{$front};
            push @{$_[0]->{back}}, $_[1];
            $_[0]->append ($_) for @{$back};
        }

        $_[0];
    }

    sub prepend_children
    {
        unshift @{$_[0]->{children}}, @_[1..$#_];
        $_[0];
    }

    sub append_children
    {
        push @{$_[0]->{children}}, @_[1..$#_];
        $_[0];
    }

    sub front    { @{$_[0]->{children}} ? $_[0]->children->[0]->front : $_[0]->{front} }
    sub children { $_[0]->{children} }
    sub back     { @{$_[0]->{children}} ? $_[0]->children->[-1]->back : $_[0]->{back}  }

    sub emit_front
    {
        my ($self, $vis_only) = @_;

        confess "Bad node" if @{$self->{front}} && @{$self->{children}};

        if (@{$self->{children}}) {
            $self->{children}->[0]->emit_front ($vis_only);
        } else {
            my $txt = "";
            for (@{$self->{front}}) {
                $txt .= $_->emit ($vis_only);
            }
            $txt;
        }
    }

    sub emit_self
    {
        my ($self, $vis_only) = @_;

        confess "Illegal emit_self call" if defined ($vis_only);

        confess "Bad node" if (@{$self->{front}} || $self->{text_self} || @{$self->{back}}) && @{$self->{children}};

        my $txt = "";

        my $children = scalar (@{$self->{children}});

        if ($children == 0) {
            $txt .= $self->{text_self};
        } elsif ($children == 1) {
            $txt .= $self->{children}->[0]->emit_self;
        } else {
            $txt .= $self->{children}->[0]->emit_self;
            $txt .= $self->{children}->[0]->emit_back;
            for (@{$self->{children}}[1..$children-2]) {
                $txt .= $_->emit;
            }
            $txt .= $self->{children}->[-1]->emit_front;
            $txt .= $self->{children}->[-1]->emit_self;
        }

        $txt;
    }

    sub emit_back
    {
        my ($self, $vis_only) = @_;

        confess "Bad node" if @{$self->{back}} && @{$self->{children}};

        if (@{$self->{children}}) {
            $self->{children}->[-1]->emit_back ($vis_only);
        } else {
            my $txt = "";
            for (@{$self->{back}}) {
                $txt .= $_->emit ($vis_only);
            }
            $txt;
        }
    }

    sub emit
    {
        my ($self, $vis_only) = @_;

        # !!! Find a better way than inspecting text_self to test for node with
        # content?
        confess "Bad node" if $self->{text_self} && @{$self->{children}};

        my $txt = "";

        #$txt .= $self->emit_front ($vis_only);
        #$txt .= $self->emit_self ($vis_only);
        #$txt .= $self->emit_back ($vis_only);

        my $children = scalar (@{$self->{children}});

        # There is a redundant check of ($children == 0) in emit_front/back.
        # This could be resolved by creating separate VP3::ParseTree::Node and
        # VP3::ParseTree::Leaf classes.
        if ($children == 0) {
            $txt .= $self->emit_front ($vis_only);
            if (!$vis_only || $self->visible) {
                $txt .= $self->emit_self;
            }
            $txt .= $self->emit_back ($vis_only);
        } else {
            for (@{$self->{children}}) {
                $txt .= $_->emit ($vis_only);
            }
        }

        $txt;
    }

} # package VP3::ParseTree

{
    package VP3::ParseTree::identifier;
    use base 'VP3::ParseTree';

    sub is_system_identifier
    {
        substr ($_[0]->{text_self}, 0, 1) eq '$' ? 1 : 0;
    }
}

{
    package VP3::ParseTree::string;
    use base 'VP3::ParseTree';

    sub emit_self
    {
        q(") . $_[0]->SUPER::emit_self . q(");
    }

}

{
    package VP3::ParseTree::based_number;
    use base 'VP3::ParseTree';

    use Carp;

    sub new
    {
        my ($class, $type, $signed, $base, $ws, $value) = @_;

        my $self = $class->SUPER::new ($type);
        $self->{width}  = undef;
        $self->{signed} = $signed || "";
        $self->{base}   = $base   || "";
        $self->{ws}     = $ws     || "";

        length ($value) or croak (__PACKAGE__ . "::new requires non-null value");

        $self->{value}  = $value;

        $self;
    }

    sub width
    {
        if ($_[1]) {
            $_[0]->{width} = $_[1];
        }

        $_[0]->{width};
    }

    sub base
    {
        if ($_[1]) {
            $_[0]->{base} = $_[1];
        }

        $_[0]->{base};
    }

    sub value
    {
        if ($_[1]) {
            $_[0]->{value} = $_[1];
        }

        $_[0]->{value};
    }

    sub emit_self
    {
        my $self = $_[0];
        "'" . $self->{signed} . $self->{base} . $self->{ws} . $self->{value};
    }

}

{

    package VP3::ParseTree::generic;
    use base 'VP3::ParseTree';

    sub new
    {
        my ($class, $type) = (shift, shift);

        my $self = $class->SUPER::new ($type, @_);
        $self->{type} = $type;
        $self;
    }

    sub type
    {
        $_[0]->{type};
    }

    sub isa
    {
        my ($self, $class) = @_;

        if ($class =~ /^VP3::ParseTree::(.*)$/ && $1 eq $self->{type}) {
            return 1;
        } else {
            return $self->SUPER::isa ($class);
        }
    }

} # package VP3::ParseTree::generic

{
    package VP3::ParseTree::source_text;
    use base 'VP3::ParseTree';

    sub modules
    {
        grep { $_->typeis ("module_declaration") } @{$_[0]->children};
    }

    sub module { ${$_[0]->module_ref (@_[1..$#_]) || \undef} }

    sub module_ref
    {
        my ($self, $which) = @_;

        my @modules = grep { $$_->typeis ("module_declaration") && $$_->module_identifier eq $which } map { \$_ } @{$self->children};

        if (@modules > 1) {
            return undef;
        } else {
            return $modules[0];
        }
    }

} # package VP3::ParseTree::source_text

{
    package VP3::ParseTree::module_declaration;
    use base 'VP3::ParseTree';

    use Data::Dumper;
    use Scalar::Util qw(blessed);
    use Carp;

    use constant {
        MODULE_KEYWORD      => 0,
        MODULE_IDENTIFIER   => 1,
        PARAMETER_PORT_LIST => 2,
        PORT_LIST           => 3,
        MODULE_ITEMS        => 4,
    };

    sub new
    {
        my $class = shift;
        my $self = $class->SUPER::new (@_);
        $self->{symtab} = VP3::Symtab->new;
        $self;
    }

    sub symtab { $_[0]->{symtab} }

    sub module_identifier
    {
        $_[0]->children->[MODULE_IDENTIFIER]->emit_self;
    }

    sub module_items
    {
        $_[0]->children->[MODULE_ITEMS];
    }

    sub port_list { $_[0]->children->[PORT_LIST] }

    # Returns the ports of this module, as a VP3::Ports object
    sub ports
    {
        my $self = shift;

        # h = Header, b = Body
        #my (%hports, %bports);
        my $bports = VP3::Ports->new;

        $bports->location ($self->location);

        my $module_items = $self->children->[MODULE_ITEMS]->children;

        if ($self->children->[PORT_LIST]->typeis ("list_of_port_identifiers")) {
            # Old-style module declaration.

            # !!! find a way to enable this?
            ## Check for consistency between module header port list and port
            ## declarations in body. Can only check this after @Ports is
            ## expanded.

            #for (@{$self->children->[PORT_LIST]->children}) {
            #    $hports{$_->emit_self}++;
            #}

            for (grep { $_->typeis ("input_declaration") ||
                        $_->typeis ("output_declaration") } @$module_items) {
                #for (grep { $_->typeis ("input_declaration") } @$module_items) {
                if ($_->typeis ("input_declaration")) {
                    my ($msb, $lsb) = (undef, undef);
                    if ($_->input_type->opt_range->typeis ("range")) {
                        $msb = VP3::Expression::evaluate ($self, $_->input_type->opt_range->msb);
                        $lsb = VP3::Expression::evaluate ($self, $_->input_type->opt_range->lsb);
                        defined $msb && defined $lsb
                            or return undef;
                    }
                    for ($_->port_names) {
                        #$bports{$_} = { name => $_, dir => "input", msb => $msb, lsb => $lsb };
                        $bports->add (VP3::Port->new (name => $_, dir => &VP3::Port::DIR_INPUT, msb => $msb, lsb => $lsb));
                    }
                }

                #for (grep { $_->typeis ("output_declaration") } @$module_items) {
                if ($_->typeis ("output_declaration")) {
                    my ($msb, $lsb) = (undef, undef);
                    if ($_->output_type->opt_range->typeis ("range")) {
                        $msb = VP3::Expression::evaluate ($self, $_->output_type->opt_range->msb);
                        $lsb = VP3::Expression::evaluate ($self, $_->output_type->opt_range->lsb);
                        defined $msb && defined $lsb
                            or return undef;
                    }
                    for ($_->port_names) {
                        #$bports{$_} = { name => $_, dir => "output", msb => $msb, lsb => $lsb };
                        $bports->add (VP3::Port->new (name => $_, dir => &VP3::Port::DIR_OUTPUT, msb => $msb, lsb => $lsb));
                    }
                }

            }

            # TODO inouts

            # !!! find a way to enable this? (if so, add back "use 5.010")
            #unless (%hports ~~ %bports) {
            #    # !!! need a much better error message
            #    print Dumper {hports => \%hports, bports => \%bports};
            #    die "Header and body ports defined in " . $self->module_identifier . " don't match\n";
            #}

        } else {
            # New-style module declarations. Ports defined in module header.

            for (grep { $_->typeis ("input_declaration") ||
                        $_->typeis ("output_declaration") } @{$self->children->[PORT_LIST]->children}) {
                #for (grep { $_->typeis ("input_declaration") } @{$self->children->[PORT_LIST]->children}) {
                if ($_->typeis ("input_declaration")) {
                    my ($msb, $lsb) = (undef, undef);
                    if ($_->input_type->opt_range->typeis ("range")) {
                        $msb = VP3::Expression::evaluate ($self, $_->input_type->opt_range->msb);
                        $lsb = VP3::Expression::evaluate ($self, $_->input_type->opt_range->lsb);
                        defined $msb && defined $lsb
                            or return undef;
                    }
                    for ($_->port_names) {
                        $bports->add (VP3::Port->new (name => $_, dir => &VP3::Port::DIR_INPUT, msb => $msb, lsb => $lsb));
                    }
                }

                #for (grep { $_->typeis ("output_declaration") } @{$self->children->[PORT_LIST]->children}) {
                if ($_->typeis ("output_declaration")) {
                    my ($msb, $lsb) = (undef, undef);
                    if ($_->output_type->opt_range->typeis ("range")) {
                        $msb = VP3::Expression::evaluate ($self, $_->output_type->opt_range->msb);
                        $lsb = VP3::Expression::evaluate ($self, $_->output_type->opt_range->lsb);
                        defined $msb && defined $lsb
                            or return undef;
                    }
                    for ($_->port_names) {
                        $bports->add (VP3::Port->new (name => $_, dir => &VP3::Port::DIR_OUTPUT, msb => $msb, lsb => $lsb));
                    }
                }

                # TODO inouts
            }

        }

        return $bports;
    }

} # package VP3::ParseTree::module_declaration

{
    package VP3::ParseTree::vp3_module_declaration;
    use base 'VP3::ParseTree::module_declaration';

    use Carp;

    use constant {
        VP3_MODULE_DIRECTIVE => 0,
        MODULE_ITEMS         => 1,
        ENDMODULE_KEYWORD    => 2,
    };

    sub vp3_module_directive { $_[0]->children->[VP3_MODULE_DIRECTIVE] }

    sub module_identifier
    {
        $_[0]->children->[VP3_MODULE_DIRECTIVE]->module_identifier;
    }

    sub module_items
    {
        $_[0]->children->[MODULE_ITEMS];
    }

    sub endmodule_keyword { $_[0]->children->[ENDMODULE_KEYWORD] }

    sub ports
    {
        VP3::fatal ("can't determine ports of a vp3_module_declaration");
    }

} # package VP3::ParseTree::vp3_module_declaration

{

    package VP3::ParseTree::assignment;
    use base 'VP3::ParseTree';

    use Carp;

    use constant {
        LHS   => 0,
        DELAY => 1,
        RHS   => 2,
    };

    sub new
    {
        my ($class) = shift;
        my ($type) = splice (@_, 1, 1);
        my $self = $class->SUPER::new (@_);
        $type eq "continuous" || $type eq "blocking" || $type eq "nonblocking"
            or croak "Invalid assignment type `$type'";
        $self->{assignment_type} = $type;
        $self;
    }

    sub assignment_type { $_[0]->{assignment_type} }

    sub lhs { $_[0]->children->[LHS] }
    sub rhs { $_[0]->children->[RHS] }

} # package VP3::ParseTree::assignment

{
    package VP3::ParseTree::binary_operator_expression;
    use base 'VP3::ParseTree';

    use constant {
        LEFT    => 0,
        OP      => 1,
        RIGHT   => 2,
    };

    sub new
    {
        my ($class) = shift;
        my $self = $class->SUPER::new (@_);
        $self->{op} = $self->children->[OP]->emit_self;
        $self;
    }

    sub op { $_[0]->{op} }

    sub left  { $_[0]->children->[LEFT]  }
    sub right { $_[0]->children->[RIGHT] }

} # package VP3::ParseTree::binary_operator_expression

{

    package VP3::ParseTree::parameter_declaration;
    use base 'VP3::ParseTree';

    use Carp;

    use constant {
        LIST_OF_PARAM_ASSIGNMENTS => 2,
    };

    sub new
    {
        my ($class) = shift;
        my ($type) = splice (@_, 1, 1);
        my $self = $class->SUPER::new (@_);
        $type eq "localparam" || $type eq "parameter"
            or croak "Invalid parameter type `$type'";
        $self->{parameter_type} = $type;
        $self;
    }

    sub parameter_type { $_[0]->{parameter_type} }

    sub decls
    {
        my $self = shift;
        my %decls;

        for (@{$self->children->[LIST_OF_PARAM_ASSIGNMENTS]->children}) {
            my $ident = $_->lhs->emit_self;
            $decls{$ident} = VP3::Symbol->new ("parameter", $_->rhs);
        }

        %decls;
    }

} # package VP3::ParseTree::parameter_declaration

{
    package VP3::ParseTree::param_assignment;
    use base 'VP3::ParseTree';

    use constant {
        LHS => 0,
        RHS => 1,
    };

    sub lhs { $_[0]->children->[LHS] }
    sub rhs { $_[0]->children->[RHS] }

} # package VP3::ParseTree::param_assignment

{

    package VP3::ParseTree::input_declaration;
    use base 'VP3::ParseTree';

    use constant {
        INPUT_KEYWORD               => 0,
        INPUT_TYPE                  => 1,
        LIST_OF_PORT_IDENTIFIERS    => 2,
    };

    sub port_names {
        my $self = shift;
        my @rtn;

        for (@{$self->children->[LIST_OF_PORT_IDENTIFIERS]->children}) {
            push @rtn, $_->emit_self;
        }

        @rtn;
    }

    sub input_type { $_[0]->children->[INPUT_TYPE] }

    sub decls
    {
        my $self = shift;
        my %decls;

        my $keyword = $self->children->[INPUT_KEYWORD]->emit_self;

        for (@{$self->children->[LIST_OF_PORT_IDENTIFIERS]->children}) {
            my $ident = $_->emit_self;
            $decls{$ident} = $keyword;
        }

        %decls;
    }

} # package VP3::ParseTree::input_declaration

{
    package VP3::ParseTree::inout_declaration;
    use base 'VP3::ParseTree::input_declaration';
}

{
    package VP3::ParseTree::input_type;
    use base 'VP3::ParseTree';

    use constant {
        TYPE        => 0,
        OPT_SIGNED  => 1,
        OPT_RANGE   => 2,
    };

    sub type        { $_[0]->children->[TYPE] }
    sub opt_signed  { $_[0]->children->[OPT_SIGNED] }
    sub opt_range   { $_[0]->children->[OPT_RANGE] }
}

{

    package VP3::ParseTree::output_declaration;
    use base 'VP3::ParseTree';

    use constant {
        OUTPUT_KEYWORD  => 0,
        OUTPUT_TYPE     => 1,
        LIST            => 2,
    };

    sub port_names {
        my $self = shift;
        my @rtn;

        my $list = $self->children->[LIST];

        if ($list->typeis ("list_of_port_identifiers")) {
            for (@{$list->children}) {
                push @rtn, $_->emit_self;
            }
        } elsif ($list->typeis ("list_of_variable_port_identifiers")) {
            for (@{$list->children}) {
                # variable_port_identifier is an identifier and an optional
                # (constant) assignment. !!! fix hardcoded [0]
                push @rtn, $_->children->[0]->emit_self;
            }
        }

        @rtn;
    }

    sub output_type { $_[0]->children->[OUTPUT_TYPE] }

    sub decls
    {
        my $self = shift;
        my %decls;

        my $list = $self->children->[LIST];

        if ($list->typeis ("list_of_port_identifiers")) {
            for (@{$list->children}) {
                my $ident = $_->emit_self;
                $decls{$ident} = "output";
            }
        } elsif ($list->typeis ("list_of_variable_port_identifiers")) {
            for (@{$list->children}) {
                # variable_port_identifier is an identifier and an optional
                # (constant) assignment. !!! fix hardcoded [0]
                my $ident = $_->children->[0]->emit_self;
                $decls{$ident} = "output";
            }
        }

        %decls;
    }

} # package VP3::ParseTree::output_declaration

{
    package VP3::ParseTree::output_type;
    use base 'VP3::ParseTree';

    use constant {
        TYPE        => 0,
        OPT_SIGNED  => 1,
        OPT_RANGE   => 2,
    };

    sub type        { $_[0]->children->[TYPE] }
    sub opt_signed  { $_[0]->children->[OPT_SIGNED] }
    sub opt_range   { $_[0]->children->[OPT_RANGE] }
}

{
    package VP3::ParseTree::reg_declaration;
    use base 'VP3::ParseTree';

    use constant {
        OPT_SIGNED                   => 0,
        OPT_RANGE                    => 1,
        LIST_OF_VARIABLE_IDENTIFIERS => 2,
    };

    sub decls
    {
        my $self = shift;
        my %decls;

        for (@{$self->children->[LIST_OF_VARIABLE_IDENTIFIERS]->children}) {
            # !!! should be a method for this
            my $ident = $_->children->[0]->emit_self;
            $decls{$ident} = "reg";
        }

        %decls;
    }

} # package VP3::ParseTree::reg_declaration

{
    package VP3::ParseTree::integer_declaration;
    use base 'VP3::ParseTree';

    use constant {
        LIST_OF_VARIABLE_IDENTIFIERS => 0,
    };

    sub decls
    {
        my $self = shift;
        my %decls;

        for (@{$self->children->[LIST_OF_VARIABLE_IDENTIFIERS]->children}) {
            # !!! should be a method for this
            my $ident = $_->children->[0]->emit_self;
            $decls{$ident} = "integer";
        }

        %decls;
    }

} # package VP3::ParseTree::integer_declaration

{
    package VP3::ParseTree::genvar_declaration;
    use base 'VP3::ParseTree';

    use constant {
        LIST_OF_GENVAR_IDENTIFIERS => 0,
    };

    sub decls
    {
        my $self = shift;
        my %decls;

        for (@{$self->children->[LIST_OF_GENVAR_IDENTIFIERS]->children}) {
            # !!! should be a method for this
            my $ident = $_->emit_self;
            $decls{$ident} = "genvar";
        }

        %decls;
    }

} # package VP3::ParseTree::genvar_declaration

{
    package VP3::ParseTree::net_declaration;
    use base 'VP3::ParseTree';

    use constant {
        NET_TYPE                    => 0,
        OPT_DRIVE_STRENGTH          => 1,
        OPT_VECTORED_OR_SCALARED    => 2,
        OPT_SIGNED                  => 3,
        OPT_RANGE                   => 4,
        OPT_DELAY3                  => 5,
        LIST                        => 6,
    };

    sub list { $_[0]->children->[LIST] }

    sub new
    {
        my $class = shift;
        my $self = $class->SUPER::new (@_);

        if ($self->children->[OPT_DRIVE_STRENGTH]->type ne "null" &&
            $self->children->[LIST]->type ne "list_of_net_decl_assignments") {
            # !!! Sanity check this error case on other tools
            die "Drive strength illegal in net declaration without assignments";
        }

        $self;
    }

    sub decls
    {
        my $self = shift;
        my %decls;

        if ($self->children->[LIST]->type eq "list_of_net_decl_assignments") {
            for (@{$self->children->[LIST]->children}) {
                # !!! should be a method for this
                my $ident = $_->children->[0]->emit_self;
                $decls{$ident} = "net";
            }
        } elsif ($self->children->[LIST]->type eq "list_of_net_identifiers") {
            for (@{$self->children->[LIST]->children}) {
                # !!! should be a method for this
                my $ident = $_->children->[0]->emit_self;
                $decls{$ident} = "net";
            }
        } else {
            VP3::fatal ("Illegal declaration list type in net_declaration")
        }

        %decls;
    }

} # package VP3::ParseTree::net_declaration

{
    package VP3::ParseTree::trireg_declaration;
    use base 'VP3::ParseTree';

    use constant {
        OPT_DRIVE_STRENGTH          => 0,
        OPT_CHARGE_STRENGTH         => 1,
        OPT_VECTORED_OR_SCALARED    => 2,
        OPT_SIGNED                  => 3,
        OPT_RANGE                   => 4,
        OPT_DELAY3                  => 5,
        LIST                        => 6,
    };

    sub new
    {
        my $class = shift;
        my $self = $class->SUPER::new (@_);

        if ($self->children->[OPT_DRIVE_STRENGTH]->type ne "null" &&
            $self->children->[LIST]->type ne "list_of_net_decl_assignments") {
            # !!! Sanity check this error case on other tools
            VP3::error ("Drive strength illegal in trireg declaration without assignments");
        }

        if ($self->children->[OPT_CHARGE_STRENGTH]->type ne "null" &&
            $self->children->[LIST]->type ne "list_of_net_identifiers") {
            VP3::error ("Charge strength illegal in trireg declaration with assignments");
        }

        $self;
    }

    sub decls
    {
        my $self = shift;
        my %decls;

        if ($self->children->[LIST]->type eq "list_of_net_decl_assignments") {
            for (@{$self->children->[LIST]->children}) {
                # !!! should be a method for this
                my $ident = $_->children->[0]->emit_self;
                $decls{$ident} = "trireg";
            }
        } elsif ($self->children->[LIST]->type eq "list_of_net_identifiers") {
            for (@{$self->children->[LIST]->children}) {
                # !!! should be a method for this
                my $ident = $_->children->[0]->emit_self;
                $decls{$ident} = "trireg";
            }
        } else {
            VP3::fatal ("Illegal declaration list type in trireg_declaration");
        }

        %decls;
    }

}

{
    package VP3::ParseTree::range;
    use base 'VP3::ParseTree';

    use constant {
        MSB => 0,
        LSB => 1,
    };

    sub msb { $_[0]->children->[MSB] }
    sub lsb { $_[0]->children->[LSB] }
}

{
    package VP3::ParseTree::range_expression_colon;
    use base 'VP3::ParseTree';

    use constant {
        LHS   => 0,
        COLON => 1,
        RHS   => 2,
    };

    sub new
    {
        my $class = shift;
        my $self = $class->SUPER::new (@_);
    }

    sub evaluate_msb
    {
        my ($self, $scope) = @_;

        my $colon = $self->children->[COLON]->emit_self;

        if ($colon eq ":") {
            return VP3::Expression::evaluate ($scope, $self->children->[LHS]);
        } elsif ($colon eq "+:") {
            # is this right for big-endian?
            my $lhs = VP3::Expression::evaluate ($scope, $self->children->[LHS]);
            my $rhs = VP3::Expression::evaluate ($scope, $self->children->[RHS]);
            return (defined ($lhs) && defined ($rhs)) ? $lhs + $rhs - 1 : undef;
        } elsif ($colon eq "-:") {
            # ditto the big-endian question
            return VP3::Expression::evaluate ($scope, $self->children->[LHS]);
        } else {
            # the parser shouldn't have produced anything else
            VP3::fatal ("Illegal colon token `" . $colon . "' in range_expression_colon");
        }
    }

    sub evaluate_lsb
    {
        my ($self, $scope) = @_;

        my $colon = $self->children->[COLON]->emit_self;

        if ($colon eq ":") {
            return VP3::Expression::evaluate ($scope, $self->children->[RHS]);
        } elsif ($colon eq "+:") {
            # is this right for big-endian?
            return VP3::Expression::evaluate ($scope, $self->children->[LHS]);
        } elsif ($colon eq "-:") {
            # ditto the big-endian question
            my $lhs = VP3::Expression::evaluate ($scope, $self->children->[LHS]);
            my $rhs = VP3::Expression::evaluate ($scope, $self->children->[RHS]);
            return (defined ($lhs) && defined ($rhs)) ? $lhs - $rhs + 1 : undef;
        } else {
            # the parser shouldn't have produced anything else
            VP3::fatal ("Illegal colon token `" . $colon . "' in range_expression_colon");
        }
    }

}

{
    package VP3::ParseTree::conditional_statement;
    use base 'VP3::ParseTree';

    use constant {
        EXPR        => 0,
        STATEMENT   => 1,
        OPT_ELSE    => 2,
    };

    sub expr        { $_[0]->children->[EXPR] }
    sub statement   { $_[0]->children->[STATEMENT] }
    sub opt_else    { $_[0]->children->[OPT_ELSE] }
}

{
    package VP3::ParseTree::case_statement;
    use base 'VP3::ParseTree';

    use constant {
        EXPR    => 0,
        ITEMS   => 1,
    };

    sub expr { $_[0]->children->[EXPR] }
    sub items { $_[0]->children->[ITEMS] }
}

{
    package VP3::ParseTree::procedural_timing_control_statement;
    use base 'VP3::ParseTree';

    use constant {
        DELAY_OR_EVENT_CONTROL  => 0,
        STATEMENT_OR_NULL       => 1,
    };

    sub delay_or_event_control  { $_[0]->children->[DELAY_OR_EVENT_CONTROL] }
    sub statement_or_null       { $_[0]->children->[STATEMENT_OR_NULL] }
}

{
    package VP3::ParseTree::module_instantiation;
    use base 'VP3::ParseTree';

    use constant {
        MODULE_IDENTIFIER           => 0,
        PARAMETER_VALUE_ASSIGNMENT  => 1,
        MODULE_INSTANCES            => 2,
    };

    sub module_identifier { $_[0]->children->[MODULE_IDENTIFIER] }
    sub module_instances  { $_[0]->children->[MODULE_INSTANCES] }

} # package VP3::ParseTree::module_instantiation

{
    package VP3::ParseTree::module_instance;
    use base 'VP3::ParseTree';

    use constant {
        NAME_OF_INSTANCE            => 0,
        LIST_OF_PORT_CONNECTIONS    => 1,
    };

    sub name_of_instance { $_[0]->children->[NAME_OF_INSTANCE] }
    sub list_of_port_connections { $_[0]->children->[LIST_OF_PORT_CONNECTIONS] }

} # package VP3::ParseTree::module_instance

{
    package VP3::ParseTree::named_port_connection;
    use base 'VP3::ParseTree';

    use constant {
        PORT_IDENTIFIER => 0,
        EXPRESSION      => 1,
    };

    sub port_identifier { $_[0]->children->[PORT_IDENTIFIER] }
    sub expression      { $_[0]->children->[EXPRESSION] }

} # package VP3::ParseTree::named_port_connection

{

    # Used for both task_enable and system_task_enable

    package VP3::ParseTree::task_enable;
    use base 'VP3::ParseTree';

    use constant {
        IDENTIFIER      => 0,
        OPT_ARGUMENTS   => 1,
    };

    sub identifier { $_[0]->children->[IDENTIFIER] }
    sub opt_arguments { $_[0]->children->[OPT_ARGUMENTS] }
}

{

    # Used for both function_call and system_function_call
    #
    # Arguments are required for user functions, but optional for system functions

    package VP3::ParseTree::function_call;
    use base 'VP3::ParseTree';

    use constant {
        IDENTIFIER  => 0,
        ARGUMENTS   => 1,
    };

    sub identifier { $_[0]->children->[IDENTIFIER] }
    sub arguments { $_[0]->children->[ARGUMENTS] }
}

{
    package VP3::ParseTree::vp3_directive;
    use base 'VP3::ParseTree';

    use constant {
        DIRECTIVE_KEYWORD => 0,
        TEXT_ITEMS => 1,
    };

    sub directive_keyword { $_[0]->children->[DIRECTIVE_KEYWORD] }

    sub directive_text
    {
        join (" ", map { $_->emit_self } @{$_[0]->children->[TEXT_ITEMS]->children});
    }
}

{
    package VP3::ParseTree::vp3_instance_directive;
    use base 'VP3::ParseTree::vp3_directive';

    use Getopt::Long;

    sub new
    {
        my $class = shift;

        my $self = $class->SUPER::new (@_);

        $self->{renames} = [ ];

        my $text = $self->directive_text;
        local (@ARGV) = VP3::Utils::directive_words ($text);

        my $odd;
        my $rv = GetOptions ("connect=s{2}" => sub {
                                                     ($odd ^= 1) ? push @{$self->{renames}}, [ $_[1] ]
                                                                 : push @{$self->{renames}->[-1]}, $_[1];
                                                   },
                             "file=s" => \$self->{file});
        $rv or do {
            VP3::error ("Couldn't parse \@Instance directive: $text");
            return VP3::ParseTree->factory (whitespace => $self->emit_self);
        };

        unless (@ARGV == 2) {
            VP3::error ("Invalid arguments to \@Instance directive: $text");
            return VP3::ParseTree->factory (whitespace => $self->emit_self);
        };

        $self->{module} = $ARGV[0];
        $self->{instance_name} = $ARGV[1];

        $self;
    }

    sub module { $_[0]->{module} }
    sub instance_name { $_[0]->{instance_name} }
    sub renames { $_[0]->{renames} }
    sub file { $_[0]->{file} }

}

{
    package VP3::ParseTree::vp3_module_directive;
    use base 'VP3::ParseTree::vp3_directive';

    use Getopt::Long;

    sub new
    {
        my $class = shift;
        my ($default_module_identifier) = splice (@_, 1, 1);

        my $self = $class->SUPER::new (@_);

        # Parse the directive using Getopt

        my $text = $self->directive_text;

        local (@ARGV) = VP3::Utils::directive_words ($text);

        my $rv = GetOptions (
            v2k => \$self->{v2k},
            "attr=s" => \$self->{attr},
            none => \$self->{opt_none},
        );
        $rv or do {
            VP3::error ("Couldn't parse \@Module directive: $text");
            return VP3::ParseTree->factory (whitespace => $self->emit_self);
        };

        unless (@ARGV <= 1) {
            VP3::error ("Invalid arguments to \@Module directive: $text");
            return VP3::ParseTree->factory (whitespace => $self->emit_self);
        }

        my ($module_identifier) = @ARGV;

        #

        $self->{module_identifier} = $module_identifier || $default_module_identifier;

        $self;
    }

    sub module_identifier { $_[0]->{module_identifier} }
    sub v2k { $_[0]->{v2k} }
    sub attr { $_[0]->{attr} }
    sub opt_none { $_[0]->{opt_none} }

} # package VP3::ParseTree::vp3_module_directive

# FIXME: inheriting from vp3_directive because it's easy. but `directive_text'
# method won't work right for these
{
    package VP3::ParseTree::vp3_ports_directive;
    use base 'VP3::ParseTree::vp3_directive';
}

{
    package VP3::ParseTree::vp3_regs_directive;
    use base 'VP3::ParseTree::vp3_directive';
}

{
    package VP3::ParseTree::vp3_wires_directive;
    use base 'VP3::ParseTree::vp3_directive';
}

{
    package VP3::ParseTree::vp3_vector_directive;
    use base 'VP3::ParseTree';

    use constant {
        WIDTH       => 0,
        IDENTIFIER  => 1,
    };

    sub width { $_[0]->children->[WIDTH] }
    sub identifier { $_[0]->children->[IDENTIFIER] }
}

{
    package VP3::ParseTree::vp3_force_directive;
    use base 'VP3::ParseTree';

    use constant {
        IDENTIFIER  => 0,
    };

    sub force_type { $_[0]->{force_type} }
    sub identifier { $_[0]->children->[IDENTIFIER] }

    sub new {
        my $class = shift;
        my $type = splice (@_, 1, 1);
        my $self = $class->SUPER::new (@_);
        $self->{force_type} = $type;
        $self;
    }
}

{
    package VP3::ParseTree::vp3_waive_directive;
    use base 'VP3::ParseTree';

    use constant {
        WAIVER_TYPE => 0,
        IDENTIFIER  => 1,
    };

    sub waiver_type { $_[0]->children->[WAIVER_TYPE]->emit_self }
    sub identifier { $_[0]->children->[IDENTIFIER]->emit_self }

}

{
    package VP3::ParseTree::identifier_subscripts;
    use base 'VP3::ParseTree';

    use constant {
        IDENTIFIER  => 0,
        SUBSCRIPTS  => 1,
    };

    # hierarchical_identifier
    sub identifier { $_[0]->children->[IDENTIFIER] }
    sub subscripts { $_[0]->children->[SUBSCRIPTS] }
}

######################################################################

#

{

    package VP3::Expander;
    use base 'VP3::ParseTreeMutator';

    use Getopt::Long;
    use Carp;

    sub new
    {
        my ($class, $vp3) = @_;
        my $self = $class->SUPER::new;
        $self->{vp3} = $vp3;
        bless $self, $class;
    }

    sub visit_vp3_instance_directive
    {

        my ($self, $target) = @_;
        my $rtn;

        # Make regexes for rename rules
        for (@{$target->renames}) {
            if ($_->[0] !~ m{^/(.*)/$}) {
                # Replacements without slashes must match the whole string, add ^ and $ anchors
                $_->[0] = qr/^$_->[0]$/;
            } else {
                # Replacements with slashes can be any regular expression; need
                # to remove the slashes before using it in perl.
                $_->[0] =~ s{(^/)|(/$)}{}g;
                $_->[0] = qr/$_->[0]/;
            }
        }

        my $I;
        my $dtext = VP3::ParseTree->factory ("whitespace", VP3::Utils::directive_comment ($target, \$I));

        my $ports;
        if ($target->file) {
            $ports = $self->{vp3}->ports ($target->module, $target->file);
        } else {
            $ports = $self->{vp3}->ports ($target->module);
        }

        # This error can fire either because the module was not found or
        # because we had a problem parsing it.
        unless ($ports) {
            VP3::error ("Can't auto-instance `" . $target->module . "' without its definition");
            return VP3::ParseTree->factory (whitespace => $target->emit);
        }

        my $comma = " ";

        $rtn .= "${I}" . $target->module . " " . $target->instance_name . " (\n";
        for (@{$ports->all_ports}) { # VP3::Ports
            my $name = $_->{name};
            my $cxn  = $name;
            my $msb = $_->{msb};
            my $lsb = $_->{lsb};
            (defined ($msb) ^ defined ($lsb))
                and confess "Internal error, half-valid range";

            for (@{$target->renames}) {
                # Should put more thought into how exactly to do this
                $cxn =~ s/$_->[0]/"\"$_->[1]\""/ee;
                    #and print STDERR "-connect: $name ( $cxn )\n";
            }

            my $range = "";
            # If the hiconn is an identifier (as opposed to an expression), and
            # the loconn is a vector, then add the range of the loconn vector
            # to the hiconn identifier
            if ($cxn =~ /^(?:
                             (?:[a-zA-Z_][a-zA-Z0-9_\$]*)   # identifier
                            |(?:\\[^\s]+\s)                 # escaped identifier
                          )$/x && defined ($msb)) {
                $range = "[" . $msb . ":" . $lsb . "]";
            }
            $rtn .= "${I}${comma}.$name($cxn$range)\n";
            $comma = ",";
        }
        $rtn .= "${I});\n";

        # Errors here are a bit tricky. If the error results from verilog we
        # generated, then that can be considered a fatal error. If the error
        # results from something the user put in a port connect expression,
        # then it's a normal error.
        my ($tree, $error);
        unless ($tree = $self->parse ("VP3_PARSE_MODE_MODULE_ITEMS", $rtn, \$error)) {
            VP3::error ("While parsing generated instantiation:\n$error\nInstantiation follows:\n$rtn");
            return $dtext;
        }

        $tree->location_set_recursive ($target->directive_keyword->source_file,
                                       $target->directive_keyword->source_line);

        # Return the new tree; will replace the vp3_instance_directive node
        ($dtext, $tree->type ne "null" ? @{$tree->children} : VP3::ParseTree->factory ("whitespace", $rtn));

    }

}

# Second pass output processing

{

    package VP3::Translator;
    use base 'VP3::ParseTreeMutator';

    use Data::Dumper;

    sub new
    {
        my ($class, $vp3) = @_;
        my $self = $class->SUPER::new;
        $self->{vp3} = $vp3;
        bless $self, $class;
    }

    sub visit_module_declaration
    {
        my ($self, $target) = @_;

        $self->{module} = $target;

        $self->{default}->($self, $target);

        undef $self->{module};

        $target;
    }

    sub visit_vp3_module_declaration
    {
        my ($self, $target) = @_;
        my $mod;

        $self->{module} = $target;

        # For v2k-style module headers, we expand the header before the module
        # contents, so that we can suppress duplicate reg/wire declarations for
        # ports. For non-v2k module headers, we expand the header after the
        # module contents, so we can copy whatever @Ports did (or didn't do).

        # Note that, when visiting a vp3_module_directive object, the visitor
        # returns the results of parsing a module_header (which is a partially
        # formed ParseTree::module_declaration object).

        if ($target->vp3_module_directive->v2k) {
            $mod = $self->visit ($target->vp3_module_directive);

            $mod->append_children ($self->visit ($target->module_items));
            $mod->append_children ($self->visit ($target->endmodule_keyword));
        } else {
            my $module_items = $self->visit ($target->module_items);
            my $endmodule_keyword = $self->visit ($target->endmodule_keyword);

            $mod = $self->visit ($target->vp3_module_directive);

            $mod->append_children ($module_items);
            $mod->append_children ($endmodule_keyword);
        }

        undef $self->{module};

        $mod;
    }

    sub visit_vp3_ports_directive
    {
        my ($self, $target) = @_;
        my $output = "";

        my $module = $self->{module}->module_identifier;

        my $indent;
        my $dtext = VP3::ParseTree::factory ("whitespace", VP3::Utils::directive_comment ($target, \$indent));

        my $conndb = $self->{vp3}{vp3}{connectivity}{$module};
        for my $ident (sort $conndb->signals) {
            my $signal_obj = $conndb->signal ($ident);

            next if $self->{module}->symtab->lookup ($ident); # Skip signals declared in source
            my %decl = $signal_obj->implicit_declaration_type;
            my $range = $signal_obj->implicit_declaration_range;
            if ($decl{input}) {
                $output .= "${indent}input "  . $range . " " . $ident . ";\n";
                # Do not insert in symbol table, will be declared later as reg or wire
                #$self->{module}->symtab->insert ($ident => "input");
                my $conn = VP3::Connectivity->new (undef, "input", "source");
                $signal_obj->add_connectivity ($conn);
            }
            if ($decl{output}) {
                $output .= "${indent}output " . $range . " " . $ident . ";\n";
                # Do not insert in symbol table, will be declared later as reg or wire
                #$self->{module}->symtab->insert ($ident => "output");
                my $conn = VP3::Connectivity->new (undef, "output", "sink");
                $signal_obj->add_connectivity ($conn);
            }
        }

        my ($tree, $error);
        $tree = $self->parse ("VP3_PARSE_MODE_MODULE_ITEMS", $output, \$error)
            or die "While parsing generated port declarations:\n$error\nDeclarations follow:\n$output";

        $tree->location_set_recursive ($target->directive_keyword->source_file,
                                       $target->directive_keyword->source_line);

        ($dtext, $tree->type ne "null" ? @{$tree->children} : VP3::ParseTree->factory ("whitespace", $output));
    }

    sub visit_vp3_regs_directive
    {
        my ($self, $target) = @_;
        my $output = "";

        my $module = $self->{module}->module_identifier;

        my $indent;
        my $dtext = VP3::ParseTree::factory ("whitespace", VP3::Utils::directive_comment ($target, \$indent));

        my $conndb = $self->{vp3}{vp3}{connectivity}{$module};
        for my $ident (sort $conndb->signals) {
            my $signal_obj = $conndb->signal ($ident);

            next if $self->{module}->symtab->lookup ($ident); # Skip signals declared in source
            my %decl = $signal_obj->implicit_declaration_type;
            my $range = $signal_obj->implicit_declaration_range;
            $decl{reg} and $output .= "${indent}reg "  . $range . " " . $ident . ";\n";
        }

        my ($tree, $error);
        $tree = $self->parse ("VP3_PARSE_MODE_MODULE_ITEMS", $output, \$error)
            or die "While parsing generated reg declarations:\n$error\nDeclarations follow:\n$output";

        $tree->location_set_recursive ($target->directive_keyword->source_file,
                                       $target->directive_keyword->source_line);

        ($dtext, $tree->type ne "null" ? @{$tree->children} : VP3::ParseTree->factory ("whitespace", $output));
    }

    sub visit_vp3_wires_directive
    {
        my ($self, $target) = @_;
        my $output = "";

        my $module = $self->{module}->module_identifier;

        my $indent;

        my $dtext = VP3::ParseTree::factory ("whitespace", VP3::Utils::directive_comment ($target, \$indent));

        #print Dumper ($self->{vp3}{vp3}{connectivity});
        my $conndb = $self->{vp3}{vp3}{connectivity}{$module};
        for my $ident (sort $conndb->signals) {
            #&VP3::debug && print STDERR "considering $ident\n";
            my $signal_obj = $conndb->signal ($ident);

            next if $self->{module}->symtab->lookup ($ident); # Skip signals declared in source
            my %decl = $signal_obj->implicit_declaration_type;
            my $range = $signal_obj->implicit_declaration_range;
            $decl{wire} and $output .= "${indent}wire "  . $range . " " . $ident . ";\n";
        }

        my ($tree, $error);
        $tree = $self->parse ("VP3_PARSE_MODE_MODULE_ITEMS", $output, \$error)
            or die "While parsing generated wire declarations:\n$error\nDeclarations follow:\n$output";

        $tree->location_set_recursive ($target->directive_keyword->source_file,
                                       $target->directive_keyword->source_line);

        ($dtext, $tree->type ne "null" ? @{$tree->children} : VP3::ParseTree->factory ("whitespace", $output));
    }

    sub visit_passthrough_directive
    {
        my ($self, $target) = @_;
        VP3::ParseTree->factory ("whitespace", VP3::Utils::directive_comment ($target));
    }

    {
        no warnings 'once';

        *visit_vp3_vector_directive = \&visit_passthrough_directive;
        *visit_vp3_force_directive = \&visit_passthrough_directive;
        *visit_vp3_waive_directive = \&visit_passthrough_directive;
    }

    sub visit_vp3_module_directive
    {
        my ($self, $target) = @_;
        my $output = "";

        my $module = $target->module_identifier;
        my $indent;

        my $dtext = VP3::ParseTree::factory ("whitespace", VP3::Utils::directive_comment ($target, \$indent));

        my $tree;

        if ($target->opt_none) {
            $tree = VP3::ParseTree->factory ("null", $dtext);
        } else {
            my $attr = $target->attr;
            if ($attr && length ($attr) > 60) {
                $attr = "(* ${attr} *)\n${indent}";
            } elsif ($attr) {
                # Empty string is false, which is what we want
                $attr = "(* ${attr} *) ";
            } else {
                $attr = "";
            }

            $output .= "${indent}${attr}module " . $module . " (\n";

            my $conndb = $self->{vp3}{vp3}{connectivity}{$module};
            my $comma = "  ";
            for my $ident (sort $conndb->signals) {
                my $signal_obj = $conndb->signal ($ident);
                my $symtab_entry = $self->{module}->symtab->lookup ($ident);
                my %decl = $signal_obj->implicit_declaration_type;

                # The behavior of @Module is different in v2k and non-v2k mode, as
                # described in the documentation. In v2k mode, @Module only
                # generates inferred ports (hence we condition on
                # implicit_declaration_type specifying input or output). In non-v2k
                # mode, we generated explicit and inferred ports, so generation is
                # conditioned on actual connectivity.
                if ($target->v2k && !$symtab_entry && ($decl{input} || $decl{output})) {
                    my $dir   = $decl{input} ? "input"  : "output";
                    my $src   = $decl{input} ? "source" : "sink"  ;
                    my $type  = $decl{reg}   ? "reg"    : "wire"  ;
                    my $range = $signal_obj->implicit_declaration_range;

                    $output .= "${indent}    ${comma}${dir} ${type} ${range} ${ident}\n";
                    $comma = ", ";

                    # Inserting in symbol table here prevents a duplicate
                    # declaration by @Regs/@Wires
                    $self->{module}->symtab->insert ($ident => $dir);
                    my $conn = VP3::Connectivity->new (undef, $dir, $src);
                    $signal_obj->add_connectivity ($conn);
                } elsif (!$target->v2k &&
                         ($signal_obj->input_connection ||
                          $signal_obj->output_connection)) {
                    $output .= "${indent}    ${comma}${ident}\n";
                    $comma = ", ";
                }
            }

            $output .= "${indent});\n";

            my ($error);
            $tree = $self->parse ("VP3_PARSE_MODE_MODULE_HEADER", $output, \$error)
                or die "While parsing generated module header:\n$error\nHeader follow:\n$output";

            $tree->prepend ($dtext);
        }

        $tree->location_set_recursive ($target->directive_keyword->source_file,
                                       $target->directive_keyword->source_line);

        $tree;
    }

} # package VP3::Translator

######################################################################

# Utilities

{

    package VP3::Utils;

    use Data::Dumper;

    # This was originally used for commenting directives in the output, but has
    # been replaced by the more sophisticated directive_comment routing. It is
    # currently used by the lexer for quoting @Unparsed directives, but not
    # clear that directive_comment doesn't apply there too.
    sub block_comment
    {
        my $text = $_[0];

        #$text =~ s{^}{// }mg;
        # Comment any non-blank lines
        $text =~ s{^(?=.*\S)}{//|}mg;

        # Add trailing newline if last line is not whitespace
        $text .= "\n" if $text =~ /\S.*(?!\n)$/m;

        $text;
    }

    # Returns commented version of directive for output.
    # First argument is a VP3::ParseTree object
    # Second argument, if given, will be filled with the indent found on the
    # source directive.
    sub directive_comment
    {
        my $debug = 0;
        my ($directive, $indent_ref) = @_;

        my ($front, $self, $back) = ("", "", "");

        $debug and print Dumper ($directive);

        my @front = @{$directive->front};
        my @back  = @{$directive->back};

        my $node;

        while ($node = shift @front) {
            if ($node->type eq "whitespace") {
                $front .= $node->emit (&VP3::ParseTree::VISIBLE_ONLY);
            } else {
                $self .= $node->emit;
                last;
            }
        }

        for $node (@front) {
            $self .= $node->emit;
        }

        $self .= $directive->emit_self;

        while ($node = pop @back) {
            if ($node->type eq "whitespace") {
                $back = $node->emit (&VP3::ParseTree::VISIBLE_ONLY) . $back;
            } else {
                push @back, $node;
                last;
            }
        }

        for $node (@back) {
            $self .= $node->emit;
        }

        $debug and print "F: >$front<\nS: >$self<\nB: >$back<\n";

        # Make $self consist of complete lines (!!! test)
        if ($front =~ s/^(.*)\z//m) {
            $self = $1 . $self;
        }

        if ("\n" ne substr ($self, -1)) {
            if ($back =~ s/\A(.*\n)//) {
                $self = $self . $1;
            } else {
                $self .= $back . "\n";
                $back = "";
            }
        }

        $debug and print "F: >$front<\nS: >$self<\nB: >$back<\n";

        my ($spaces, $tabs, $indent);

        # Determine the minimum whitespace on any lines (consider either spaces or tabs)
        while ($self =~ /^( *)/gm) {
            my $l = length $1;
            $spaces = $l if (!defined ($spaces) || $l < $spaces);
        }

        while ($self =~ /^(\t*)/gm) {
            my $l = length $1;
            $tabs = $l if (!defined ($tabs) || $l < $tabs);
        }

        if (defined ($spaces) && $spaces > 0) {
            $indent = " " x $spaces;
        } elsif (defined ($tabs) && $tabs > 0) {
            $indent = "\t" x $tabs;
        } else {
            $indent = "";
        }

        $self =~ s{(?<=^$indent)}{//|}mg;

        # Return indentation to caller if desired
        $$indent_ref = $indent if $indent_ref;

        $front . $self . $back;
    }

    # Word splitting for directive arguments.
    #  * words are separated by white space
    #  * white space within double quotes is ignored
    #  * a double quote within double quotes may be specified by backslash-escaping it
    #  * single quotes do not have special treatment
    sub directive_words
    {
        my $text = $_[0];

        $text =~ s/^\s*//;
        $text =~ s/\s*$//;

        my $word = "";
        my @rtn;

        while ($text =~ m/\G
                          (?:
                               ([^"\s]+)            # anything other than quote or whitespace
                              |(?:                  # a quoted section, which:
                                  "                 #   starts with a quote,
                                  ((?:\\"|[^"])*)   #   contains backslash-escaped quotes or non-quote chars, and
                                  "                 #   ends with a quote
                               )
                              |(\s*)
                          )
                         /gsx) {

            if (defined ($1))    { $word .= $1 }
            elsif (defined ($2)) { $word .= $2 }
            else {
                # Process backslash-escaped quotes
                $word =~ s/\\"/"/g;
                push @rtn, $word;
                $word = "";
            }

        }

        @rtn;
    }

} # package VP3::Utils

######################################################################

# Lexical analysis and parsing

{
    package VP3::Conditionals;

    # For "else if" sections, we need to keep track of whether we are skipping
    # because we already included a section for this conditional, or because
    # all of the conditionals so far have been false. (This determines whether
    # we will include an "else" section.) For the actual "else", we don't need
    # to track this information, so just INCL/EXCL is sufficient.
    # IFDEF_COND_SKIP is for nested ifdefs within excluded sections.
    use constant {
        IFDEF_COND_INCL  => 0,
        IFDEF_COND_EXCL  => 1,
        IFDEF_COND_SKIP  => 2,
        IFDEF_ELSIF_INCL => 3,
        IFDEF_ELSIF_EXCL => 4,
        IFDEF_ELSIF_SKIP => 5,
        IFDEF_ELSE_INCL  => 6,
        IFDEF_ELSE_EXCL  => 7,
    };

    sub new
    {
        my $class = shift;
        my $self = {
            stack => [ ],
        };
        return bless $self, $class;
    }

    sub ifdef
    {
        my ($self, $cond) = @_;

        if (0 == @{$self->{stack}}) {
            push @{$self->{stack}}, $cond ? IFDEF_COND_INCL : IFDEF_COND_EXCL;
        } else {
            my ($last, $next);
            $last = $self->{stack}->[-1];

            if ($last == IFDEF_COND_EXCL ||
                $last == IFDEF_COND_SKIP ||
                $last == IFDEF_ELSIF_EXCL ||
                $last == IFDEF_ELSIF_SKIP ||
                $last == IFDEF_ELSE_EXCL) {

                $next = IFDEF_COND_SKIP;
            } else {
                $next = $cond ? IFDEF_COND_INCL : IFDEF_COND_EXCL;
            }

            push @{$self->{stack}}, $next;
        }

        &VP3::debug && print STDERR "ifdef/ifndef: stack=" . join (",", @{$self->{stack}}) . "\n";

        $self->is_enabled;
    }

    sub elsif
    {
        my ($self, $cond) = @_;

        if (0 == @{$self->{stack}}) {
            VP3::error ("elsif not within ifdef or ifndef");
            return $self->is_enabled;
        }

        my ($last, $next);
        $last = $self->{stack}->[-1];

        $last == IFDEF_COND_EXCL  ||
        $last == IFDEF_ELSIF_EXCL    and $next = $cond ? IFDEF_ELSIF_INCL : IFDEF_ELSIF_EXCL;

        $last == IFDEF_COND_INCL  ||
        $last == IFDEF_COND_SKIP  ||
        $last == IFDEF_ELSIF_INCL ||
        $last == IFDEF_ELSIF_SKIP    and $next = IFDEF_ELSIF_SKIP;

        $last == IFDEF_ELSE_INCL  ||
        $last == IFDEF_ELSE_EXCL     and do { VP3::error ("else followed by elsif"); return $self->is_enabled };

        $self->{stack}->[-1] = $next;

        &VP3::debug && print STDERR "`elsif: stack=" . join (",", @{$self->{stack}}) . "\n";

        $self->is_enabled;
    }

    sub else
    {
        my $self = shift;

        if (0 == @{$self->{stack}}) {
            VP3::error ("else not within ifdef or ifndef");
            return $self->is_enabled;
        }

        my ($last, $next);
        $last = $self->{stack}->[-1];

        $last == IFDEF_COND_EXCL  ||
        $last == IFDEF_ELSIF_EXCL    and $next = IFDEF_ELSE_INCL;

        $last == IFDEF_COND_INCL  ||
        $last == IFDEF_COND_SKIP  ||
        $last == IFDEF_ELSIF_INCL ||
        $last == IFDEF_ELSIF_SKIP    and $next = IFDEF_ELSE_EXCL;

        $last == IFDEF_ELSE_INCL  ||
        $last == IFDEF_ELSE_EXCL     and do { VP3::error ("Multiple else directives for one ifdef"); return $self->is_enabled };

        $self->{stack}->[-1] = $next;

        &VP3::debug && print STDERR "`else: stack=" . join (",", @{$self->{stack}}) . "\n";

        $self->is_enabled;
    }

    sub endif
    {
        my $self = shift;

        if (0 == @{$self->{stack}}) {
            VP3::error ("endif without matching ifdef / ifndef");
            return $self->is_enabled;
        }

        pop @{$self->{stack}};

        &VP3::debug && print STDERR "endif: stack=" . join (",", @{$self->{stack}}) . "\n";

        $self->is_enabled;
    }

    # Returns 1 if processing is currently active, 0 if not
    sub is_enabled
    {
        my $self = shift;

        if (0 == @{$self->{stack}}) {
            return 1;
        } else {
            my $state = $self->{stack}->[-1];

            if ($state == IFDEF_COND_EXCL ||
                $state == IFDEF_COND_SKIP ||
                $state == IFDEF_ELSIF_EXCL ||
                $state == IFDEF_ELSIF_SKIP ||
                $state == IFDEF_ELSE_EXCL) {
                return 0;
            } else {
                return 1;
            }
        }
    }

    # Return the current depth of ifdefs (0 = not within any ifdefs)
    sub depth { @{$_[0]->{stack}} }

} # package VP3::Conditionals

{

    package VP3::Lexer;

    use IO::File;
    use Data::Dumper;
    use Carp;

    use constant {
        ST_INSERT       => 0,
        ST_DEFAULT      => 1,
        ST_COMMENT      => 2,
        ST_DIRECTIVE    => 3,
        ST_UNPARSED     => 4,
        ST_IFDEF_SKIP   => 5,
        ST_EOF          => 6,
    };

    # Special tokens
    my $unparsed = qr/\@Unparsed/;

    # These tokens introduce directives containing arbitrary text, terminated by a ;
    # Upon encountering a token in this list, the lexer will slurp text up to the next ;
    my $dtok = sub { my $x = join ("|", map { quotemeta $_ } @_); qr/(?:$x)(?=[^\w\$])/ }->(
        '@Module',
        '@Instance',
    );

    # Operator tokens. When multiple operators share a common prefix, the
    # longest must be listed first.
    my $otok = sub { my $x = join ("|", map { quotemeta $_ } @_); qr/(?:$x)/ }->(
        '@',
        '#',
        '.',
        ';',
        ',',
        '?',
        '<=',
        '<<<',
        '<<',
        '<',
        '>=',
        '>>>',
        '>>',
        '>',
        '(*)',
        '(*',
        '(',
        ')',
        '[',
        ']',
        ':',
        '{',
        '}',
        '+:',
        '+',
        '-:',
        '-',
        '~^',
        '~|',
        '~&',
        '~',
        '&&',
        '&',
        '||',
        '|',
        '^~',
        '^',
        '*)',
        '**',
        '*>',
        '*',
        '!==',
        '!=',
        '!',
        '/',
        '%',
        '===',
        '==',
        '=',
    );

    # Keyword tokens. Recognized only when followed by a non-identifier
    # character (which may be a newline), so that we don't identify something
    # like "edge_count" as a keyword.
    my $ktok = sub { my $x = join ("|", map { quotemeta $_ } @_); qr/(?:$x)(?=[^\w\$])/ }->(qw(
        @Ports
        @Regs
        @Wires
        @Vector
        @Input
        @Output
        @Waive
        always
        and
        assign
        automatic
        begin
        buf
        bufif0
        bufif1
        case
        casex
        casez
        cell
        cmos
        config
        deassign
        default
        defparam
        design
        disable
        edge
        else
        endcase
        endconfig
        endfunction
        endgenerate
        endmodule
        endprimitive
        endspecify
        endtable
        endtask
        end
        event
        force
        forever
        fork
        for
        function
        generate
        genvar
        highz0
        highz1
        ifnone
        if
        incdir
        include
        initial
        inout
        input
        instance
        integer
        join
        large
        liblist
        library
        localparam
        macromodule
        medium
        module
        nand
        negedge
        nmos
        nor
        noshowcancelled
        not
        notif0
        notif1
        or
        output
        parameter
        pmos
        posedge
        primitive
        pull0
        pull1
        pulldown
        pullup
        real
        pulsestyle_onevent
        pulsestyle_ondetect
        rcmos
        realtime
        real
        reg
        release
        repeat
        rnmos
        rpmos
        rtran
        rtranif0
        rtranif1
        scalared
        showcancelled
        signed
        small
        specify
        specparam
        strong0
        strong1
        supply0
        supply1
        table
        task
        time
        tran
        tranif0
        tranif1
        tri
        tri0
        tri1
        triand
        trior
        trireg
        use
        vectored
        wait
        wand
        weak0
        weak1
        while
        wire
        wor
        xnor
        xor
    ));

    #               Default     Comment     Directive   Unparsed
    # @Unparsed     X           -           -           X (SOL)
    # .*            -           X           X           X
    # Whitespace    X           -           -           -
    # /*            X           -           X           -
    # */            -           X           -           -
    # //            X           -           X           -
    # `include      X (SOL)     -           -           -
    # All others    X           -           -           -

    # Portions of the lexer here are duplicated in VP3::Preprocessor::standard

    # Parser-disabled sections. The (\s*) at the start of the first case works
    # because we always match one or the other of the alternatives the first
    # time the input line is matched. (i.e. this regex is only matched against
    # strings where the start-of-string is also start-of-line in the input)
    my $re_unparsed = qr/^(?:
         (?:(\s*)($unparsed\s*(\S+)\s*;\s*$))
        |((?s).*$)
    )/x;

    # In /* */ comments
    my $re_comment_body = qr/^(?:
         (.*?\*\/)              # $1: comment terminator
        |((?s).*$)              # $2: anything else
    )/x;

    my $re_comment_start = qr/^(?:
         (\/\*)                 # $1: start of multiline comment
        |(\/\/.*\n)             # $2: single line comment
    )/x;

    my $re_directive = qr/^(?:
         (?:([^;]+?)(?=\/\/|\/\*|$|;))  # $1: slurp up to comment, newline, or semicolon
        |(;)                            # $2: semicolon
    )/x;

    # !!! Many of these use \w incorrectly to match identifiers

    my $re_conditional = qr/^(?:
         (\s*`endif(?=[^\w\$]))     # $1: endif
        |(\s*`if(n)?def\s+(\w+))    # $2, $3, $4: ifdef or ifndef
        |(\s*`elsif\s+(\w+))        # $5, $6: elsif
        |(\s*`else(?=[^\w\$]))      # $7: else
    )/x;

    my $re_default = qr/^(?:
         ($unparsed\s*(\S+)\s*;\s*$)                # $1, $2: start of unparsed section
        |(\s+)                                      # $3: whitespace
        |($dtok)                                    # $4: directive-starting tokens
        |(`timescale\s.*\n)                         # $5: `timescale
        |(`include\s+"(.*)"\s*\n)                   # $6, $7: `include
        |(`define\s+(\w+)(?:\s+(.*)\n)?)            # $8, $9, $10: `define
        |(?:`line\s+(\d+)\s+"(.*)"\s+(\d)\s*\n)     # $11, $12, $13: `line
        |(")                                        # $14: string
        |(?i:'(s)?([bodh])(\s*)
          ([0-9a-fxz?][0-9a-fxz?_]*))               # $15, $16, $17, $18: based number
        |([0-9][0-9_]*)                             # $19: unsigned number
        |($ktok)                                    # $20: keywords
        |($otok)                                    # $21: operator tokens
        |([a-zA-Z_][a-zA-Z0-9_\$]*)                 # $22: identifier
        |(?:(\\[^\s]+)(?=\s))                       # $23: escaped identifier
        |(\$[a-zA-Z0-9_\$]+)                        # $24: system identifier
        |(`undef\s+(\w+)\s*\n)                      # $25, $26: `undef
        |(?:`(\w+)(?=\W))                           # $27: text macro reference
                                                    #      (must be after preprocessor directives)
    )/x;

    sub new
    {
        my ($class, $parse_mode) = @_;

        $parse_mode ||= "VP3_PARSE_MODE_SOURCE_TEXT";

        my $self = {
            source          => [ ],
            file            => undef,
            fh              => undef,
            buffer          => undef,
            line            => 0,
            ws_text         => "",
            ws_toks         => [ ],
            state           => ST_INSERT,
            states          => [ ],
            #start_of_line   => 0,
            ifdefs          => VP3::Conditionals->new,
            defines         => { },
            includes        => [ ],
            insert_toks     => [ $parse_mode ],
        };
        return bless $self, $class;
    }

    sub input
    {
        use Scalar::Util qw(openhandle);

        my ($self, $fh, $name) = @_;

        if ($self->{fh} || @{$self->{source}}) {
            VP3::fatal ("lexer input stream is already open");
        }

        unless (openhandle ($fh)) {
            VP3::fatal ("\$fh argument isn't an open handle");
        }

        $self->{fh}     = $fh;
        $self->{file}   = $name;
        $self->{buffer} = "";

        1;
    }

    sub depend_cb
    {
        $_[0]->{depend_cb} = $_[1];
    }

    sub lex
    {

        my ($self) = shift;
        my $tobj;

        while (1) {

            if ($self->{state} == ST_INSERT) {
                my $tok = shift @{$self->{insert_toks}};
                if (!@{$self->{insert_toks}}) {
                    $self->{state} = ST_DEFAULT;
                }
                return ($tok, undef);
            } elsif ($self->{state} == ST_EOF) {
                return ('', undef);
            }

            while ($self->{buffer} eq "") {

                $self->{buffer} = $self->{fh}->getline;
                $self->{line}++;
                #$self->{start_of_line} = 1;

                if (!defined $self->{buffer}) {

                    # Is splitting of `ifdefs across include file boundaries
                    # allowed? Assuming yes. Otherwise unterminated ifdefs
                    # should be checked outside this conditional.

                    if (@{$self->{source}}) {
                        # Reached end of an include file or `define, pop the stack
                        $self->flush_whitespace;
                        ($self->{file}, $self->{fh}, $self->{buffer}, $self->{line}) = @{pop @{$self->{source}}};
                        #$self->{start_of_line} = 0;
                    } else {
                        # Reached end of top-level source file

                        # !!! Need to more thoroughly handle all cases where $self->{states} is non-empty

                        if ($self->{ifdefs}->depth) {
                            # !!! Should report where the ifdef started
                            VP3::error ("Unterminated `ifdef");
                        }

                        $self->{state} = ST_EOF;
                        $tobj = VP3::ParseTree->factory ("eof", "");
                        $self->token ($tobj);
                        return ('EOF', $tobj);
                    }
                }

            }

            #print "buffer ($self->{line}, $self->{state}): >" . $self->{buffer} . "<\n";

            if ($self->{state} == ST_UNPARSED && $self->{buffer} =~ s/$re_unparsed//) {

                if ($2) {
                    my ($ws, $text, $command) = ($1, $2, $3);
                    if ($command eq "end") {
                        $self->{state} = pop @{$self->{states}};
                        $self->{ws_text} .= $ws . VP3::Utils::block_comment ($text);
                        next;
                    } elsif ($command eq "begin") {
                        VP3::error ("\@Unparsed sections cannot be nested");
                        # continue, still in @Unparsed section
                    } else {
                        VP3::error ("Valid commands for \@Unparsed are `begin' and `end'");
                        # continue, still in @Unparsed section
                    }
                } elsif ($4) {
                    $self->{ws_text} .= $4;
                    next;
                } else {
                    VP3::fatal ("in lexer, ST_UNPARSED");
                }

            } elsif ($self->{state} == ST_COMMENT && $self->{buffer} =~ s/$re_comment_body//) {

                if ($1) {
                    $self->{ws_text}    .= $1;
                    $self->{state}      = pop @{$self->{states}};
                    next;
                } elsif ($2) {
                    $self->{ws_text}    .= $2;
                    next;
                } else {
                    VP3::fatal ("in lexer, ST_COMMENT");
                }

            } elsif (($self->{state} == ST_DIRECTIVE || $self->{state} == ST_DEFAULT) &&
                     $self->{buffer} =~ s/$re_comment_start//) {

                if ($1) {
                    $self->{ws_text}    .= $1;

                    push @{$self->{states}}, $self->{state};
                    $self->{state} = ST_COMMENT;
                    next;
                } elsif ($2) {
                    $self->{ws_text}    .= $2;
                    next;
                } else {
                    VP3::fatal ("in lexer, ST_DIRECTIVE || ST_DEFAULT");
                }

             } elsif ($self->{state} == ST_DIRECTIVE && $self->{buffer} =~ s/$re_directive//) {

                if ($1) {
                    $tobj = VP3::ParseTree->factory ("vp3_directive_text", $1);
                    $self->token ($tobj);
                    return ('vp3_directive_text', $tobj);
                } elsif ($2) {
                    $self->{state} = pop @{$self->{states}};
                    $tobj = VP3::ParseTree->factory ("token", ';');
                    $self->token ($tobj);
                    return (';', $tobj);
                } else {
                    VP3::fatal ("in lexer, ST_DIRECTIVE");
                }

            } elsif (($self->{state} == ST_DEFAULT || $self->{state} == ST_IFDEF_SKIP) &&
                     $self->{buffer} =~ s/$re_conditional//) {

                if ($1) {
                    # `endif

                    $self->{ws_text} .= $1;

                    $self->{state} = $self->{ifdefs}->endif ? ST_DEFAULT : ST_IFDEF_SKIP;
                    next;

                } elsif ($2) {
                    # `ifdef or `ifndef

                    my ($command, $sense, $name) = ($2, $3, $4);

                    $self->{ws_text} .= $command;

                    my $cond = defined ($sense) ^ exists ($self->{defines}->{$name});

                    $self->{state} = $self->{ifdefs}->ifdef ($cond) ? ST_DEFAULT : ST_IFDEF_SKIP;
                    next;

                } elsif ($5) {
                    # `elsif
                    my ($command, $name) = ($5, $6);

                    $self->{ws_text} .= $command;

                    my $cond = exists ($self->{defines}->{$name});

                    $self->{state} = $self->{ifdefs}->elsif ($cond) ? ST_DEFAULT : ST_IFDEF_SKIP;
                    next;

                } elsif ($7) {
                    # `else

                    $self->{ws_text} .= $7;

                    $self->{state} = $self->{ifdefs}->else ? ST_DEFAULT : ST_IFDEF_SKIP;
                    next;

                } else {

                    VP3::fatal ("in lexer, ST_DEFAULT || ST_IFDEF_SKIP");

                }

            } elsif ($self->{state} == ST_IFDEF_SKIP) {

                # The LRM says (19.4) "NOTE--Any group of lines that the
                # compiler ignores still has to follow the Verilog HDL lexical
                # conventions for white space, comments, numbers, strings,
                # identifiers, keywords, and operators."

                # It's not clear from that whether we are required to raise an
                # error if the ifdef-disabled source is not valid, or just that
                # we are entitled to. Currently no error is raised.

                $self->{ws_text} .= $self->{buffer};
                $self->{buffer} = "";
                next;

            } elsif ($self->{state} == ST_DEFAULT && $self->{buffer} =~ s/$re_default//) {

                if ($1) {
                    # @Unparsed directive
                    my ($text, $command) = ($1, $2);

                    if ($command eq "begin") {
                        push @{$self->{states}}, $self->{state};
                        $self->{state} = ST_UNPARSED;
                        $self->{ws_text} .= VP3::Utils::block_comment ($text);
                        next;
                    } elsif ($command eq "end") {
                        VP3::error ("Found `\@Unparsed end' without matching `\@Unparsed begin'");
                        # continue, not in unparsed section
                    } else {
                        VP3::error ("Valid commands for \@Unparsed are `begin' and `end'");
                        # continue, not in unparsed section
                    }

                } elsif ($3) {
                    # Whitespace

                    $self->{ws_text} .= $3;
                    next;

                } elsif ($4) {
                    # Unparsed vp3 directives

                    my $tok = $4;

                    $tobj = VP3::ParseTree->factory ("token", $tok);
                    $self->token ($tobj);

                    push @{$self->{states}}, $self->{state};
                    $self->{state} = ST_DIRECTIVE;

                    return ($tok, $tobj);

                } elsif ($5) {
                    # `timescale

                    $self->{ws_text} .= $5;
                    next;

                } elsif ($6) {
                    # `include

                    # !!! spec says only whitespace and comment is allowed on
                    # the line, need to anchor to start-of-line somehow

                    $self->{ws_text}    .= $6;

                    $self->include ($7);
                    next;

                } elsif ($8) {
                    # `define

                    $self->{ws_text} .= $8;

                    $self->define ($9, defined ($10) ? $10 : "");
                    next;

                } elsif ($25) {

                    $self->{ws_text} .= $25;
                    $self->undefine ($26);
                    next;

                } elsif (defined ($11)) {

                    # The `line directive specifies the line number of the next
                    # line. Subtract one here; the line counter will be
                    # incremented when the next line is read.
                    $self->{line} = $11 - 1;
                    $self->{file} = $12;

                    # $13 is "level", with the following meanings:
                    # 1: start of include file
                    # 2: end of include file
                    # 0: neither of the previous cases applies

                    next;

                } elsif ($27) {
                    # text macro reference

                    $self->{ws_text}    .= "`$27";

                    if (!$self->expand ($27)) {
                        VP3::error ("Undefined text macro, or unsupported compiler directive `$27");
                    }

                    next;

                } elsif ($14) {

                    # !!! escape sequences

                    if ($self->{buffer} =~ s/^([^"]*)"//) {
                        $tobj = VP3::ParseTree->factory ("string", $1);
                        $self->token ($tobj);
                        return ('STRING', $tobj);
                    } else {
                        VP3::error ("Syntax error, unterminated string"); # !!! better error

                        # Assume the string was to terminate at EOL
                        $self->{buffer} =~ s/(.*)//;
                        $tobj = VP3::ParseTree->factory ("string", $1);
                        $self->token ($tobj);
                        return ('STRING', $tobj);
                    }

                } elsif (defined ($18)) {

                    $tobj = VP3::ParseTree->factory ("based_number", $15, $16, $17, $18);
                    $self->token ($tobj);
                    return ('BASED_NUMBER', $tobj);

                } elsif (defined ($19)) {

                    $tobj = VP3::ParseTree->factory ("unsigned_number", $19);
                    $self->token ($tobj);
                    return ('UNSIGNED_NUMBER', $tobj);

                } elsif ($20) {

                    my $tok = $20;
                    $tobj = VP3::ParseTree->factory ("token", $tok);
                    $self->token ($tobj);
                    return ($tok, $tobj);

                } elsif ($21) {

                    my $tok = $21;
                    $tobj = VP3::ParseTree->factory ("token", $tok);
                    $self->token ($tobj);
                    return ($tok, $tobj);

                } elsif ($22) {

                    $tobj = VP3::ParseTree->factory ("identifier", $22);
                    $self->token ($tobj);
                    return ('IDENTIFIER', $tobj);

                } elsif ($23) {

                    $tobj = VP3::ParseTree->factory ("identifier", $23);
                    $self->token ($tobj);
                    return ('IDENTIFIER', $tobj);

                } elsif ($24) {

                    $tobj = VP3::ParseTree->factory ("identifier", $24);
                    $self->token ($tobj);
                    return ('SYSTEM_IDENTIFIER', $tobj);

                } else {

                    VP3::fatal ("in lexer, ST_DEFAULT, line $self->{line}, buffer: $self->{buffer}");

                }

            } else {

                # !!! high priority to make this non-fatal
                VP3::error_fatal ("Syntax error at:\n" . $self->{buffer});

            }

        } # while (1)

    } # sub lex

    sub flush_whitespace
    {
        my ($self) = @_;

        return unless length $self->{ws_text};

        my $tobj = VP3::ParseTree->factory ("whitespace", $self->{ws_text});
        $self->{ws_text} = "";

        if (@{$self->{source}}) {
            # Preprocessor-generated tokens should not appear in output
            $tobj->visible (0);
        }

        #print Data::Dumper->Dump ([$tobj], ["ws_tok"]);

        push @{$self->{ws_toks}}, $tobj;
    }

    sub token
    {
        my ($self, $tobj) = @_;
        $tobj->source_line ($self->{line});
        $tobj->source_file ($self->{file});

        $self->flush_whitespace;

        #print Data::Dumper->Dump ([$tobj], ["token"]);

        while (@{$self->{ws_toks}}) {
            $tobj->prepend (pop @{$self->{ws_toks}});
        }

        if (@{$self->{source}}) {
            # Preprocessor-generated tokens should not appear in output
            $tobj->visible (0);
        }

        # Grab whitespace after token up to newline. This allows more accurate
        # transcription of commented source in output (the single token has
        # enough information to determine whether adding an extra newline after
        # the directive is required)

        if ($self->{buffer} && $self->{buffer} =~ s/^(\s*\n)//) {
            $tobj->append_text ($1);
        }
    }

    sub depend
    {
        my $self = shift;
        $self->{depend_cb} && $self->{depend_cb}->(@_);
    }

    sub include_path
    {
        my ($self, $path) = @_;

        push @{$self->{includes}}, $path;
    }

    sub find_include
    {
        my ($self, $file) = @_;

        $self->depend ("vinc", $file);

        for (@{$self->{includes}}) {
            my $path = File::Spec->catfile ($_, $file);

            return $path if -f $path;
        }

        return undef;
    }

    sub include
    {
        my ($self, $ifile) = @_;
        my ($fh);

        my $file = $self->find_include ($ifile);
        unless ($file) {
            VP3::error ("Couldn't find include file $ifile");
            return;
        }

        &VP3::debug && print STDERR "Including $ifile ($file)\n";

        $self->flush_whitespace;
        unless ($fh = IO::File->new ($file)) {
            VP3::error ("can't open $file");
            return;
        }

        push @{$self->{source}}, [ $self->{file}, $self->{fh}, $self->{buffer}, $self->{line} ];

        $self->{fh} = $fh;
        $self->{buffer} = "";
        $self->{line} = 0;
    }

    sub define
    {
        my ($self, $name, $value) = @_;

        &VP3::debug && print STDERR "Defining $name as `$value'\n";

        $self->{defines}->{$name} = $value;
    }

    sub undefine
    {
        my ($self, $name) = @_;

        &VP3::debug && print STDERR "undef-ing $name\n";

        if (exists ($self->{defines}->{$name})) {
            delete $self->{defines}->{$name};
        } else {
            VP3::warning ("argument `$name' to `undef has not been defined");
        }
    }

    sub ifdef
    {
        my ($self, $name) = @_;

    }

    sub expand
    {
        my ($self, $name) = @_;
        my ($fh);

        if (!exists ($self->{defines}->{$name})) {
            return undef;
        }

        my $expn = $self->{defines}->{$name};

        # !!! detect recursion
        while ($expn =~ /`(\w+)/g) {
            if (!exists ($self->{defines}->{$1})) {
                VP3::error ("Undefined text macro `$1");
                return 1; # Suppress error
            }

            &VP3::debug && print STDERR "expand $1 as ", $self->{defines}->{$1}, "\n";
            substr ($expn, $-[1] - 1, $+[1] - $-[1] + 1) = $self->{defines}->{$1};
            pos ($expn) = $-[1] - 1;
        }

        $self->flush_whitespace;
        $fh = IO::File->new;

        # Calling IO::File->open to read from a scalar works in 5.10 but not 5.8.8

        CORE::open ($fh, "<", \$expn)
            or VP3::fatal ("unable to open string as a filehandle: $!");

        push @{$self->{source}}, [ $self->{file}, $self->{fh}, $self->{buffer}, $self->{line} ];

        $self->{file} = undef;
        $self->{fh} = $fh;
        $self->{buffer} = "";
        $self->{line} = 0;

        return 1;
    }

} # package VP3::Lexer

{
    package VP3::UserFunctions;

    my (@list) = qw(vexpr vports);

    sub install
    {
        my ($where) = $_[0];

        no strict 'refs';

        for my $f (@list) {
            *{$where . '::' . $f} = sub { $f->(${$where . '::vp3'}, @_) };
        }
    }

    sub vexpr {
        my $vp3 = shift;
        my $text = join (" ", @_);

        my $mod = VP3::ParseTree->factory ("module_declaration");

        my $p = VP3::Parser->new;
        $p->scope ($mod);
        $p->YYData->{lexer} = VP3::Lexer->new ("VP3_PARSE_MODE_EXPRESSION");

        open (my $fh, "<", \$text)
            or VP3::fatal ("unable to open string as a filehandle: $!");
        $p->YYData->{lexer}->input ($fh, undef);

        my $expr = $p->YYParse (
            yylex   => sub { $_[0]->YYData->{lexer}->lex (@_[1..$#_]) },
            yyerror => \&VP3::Parser::default_yyerror,
        );

        if (!$expr) {
            VP3::error ("parse error in vexpr: " . $p->YYData->{error});
            return "";
        }

        VP3::Expression::evaluate ($mod, $expr);
    }

    sub vports {
        my $vp3 = shift;
        $vp3->ports (@_);
    }

}

{
    package VP3::Preprocessor::standard;

    use IO::File;
    use Getopt::Long;
    use Carp;
    use File::Spec;

    use Symbol qw();

    use constant {
        ST_DEFAULT => 0,
        ST_COMMENT => 1,
        ST_PERL    => 2,
    };

    my $package_counter = 0;

    my %defer_directives;
    for (qw(Module Ports Regs Wires Vector Input Output Waive Unparsed Instance)) {
        $defer_directives{$_} = 1;
    }

    # This is a reduced version of the full Verilog lexer in VP3::Lexer. The
    # two need to be kept roughly in sync.

    # In /* */ comments
    my $re_comment_body = qr/\G(?:
         (.*?\*\/)              # $1: comment terminator
        |((?s).*$)              # $2: anything else
    )/x;

    my $re_directive = qr/\G^(\s*)\@(\w+)\s*(.*\n)$/;

    my $re_default = qr/\G(.*?)(?:                  # $1: unparsed text
         (\/\*)                                     # $2: start of multiline comment
        |(\/\/.*\n)                                 # $3: single line comment
        |(")                                        # $4: string
        |(?:(\\[^\s]+)(?=\s))                       # $5: escaped identifier
        |(\n$)                                      # $6: end-of-line
    )/x;

    sub new
    {
        my ($class, $vp3) = @_;

        my $pkg_name  = "VP3::Preprocessor::standard::GEN" . $package_counter++;

        my $self = {
            conditionals    => VP3::Conditionals->new,
            include_paths   => [ ],
            defines         => { },
            enabled         => 1,
            stack           => [ ],
            state           => ST_DEFAULT,
            fh              => undef,
            perl_start      => undef,
            pkg_name        => $pkg_name,
            pkg_stash       => do { no strict 'refs'; \%{$pkg_name . '::'} },
            depends         => [ ],
            depends_mode    => 0,
        };
        bless $self, $class;

        no strict 'refs';
        *{$self->{pkg_name} . '::vprint'} = sub {
            print { $self->{output} } @_;
        };

        ${$self->{pkg_name} . '::vp3'} = $vp3;

        VP3::UserFunctions::install ($self->{pkg_name});

        $self;
    }

    sub DESTROY
    {
        Symbol::delete_package ($_[0]->{pkg_name});
    }

    sub depends_mode {
        $_[0]->{depends_mode} = $_[1];
    }

    sub depends {
        @{$_[0]->{depends}};
    }

    sub depend {
        push @{$_[0]->{depends}}, [ @_[1..$#_] ];
    }

    sub includes { push @{$_[0]->{include_paths}}, @_[1..$#_]; }

    sub include
    {
        my ($self, $ifile) = @_;
        my $fh;
        my @search;

        $self->depend ("inc", $ifile);

        push @search, grep { -f $_ } map (File::Spec->catfile ($_, $ifile), @{$self->{include_paths}});
        push @search, $ifile if -f $ifile;

        for (@search) {
            unless ($fh = IO::File->new ($_)) {
                VP3::warning ("can't open $_: $!");
                next;
            }

            push @{$self->{stack}}, $self->{fh};
            $self->{fh} = $fh;
            return;
        }

        VP3::error ("couldn't find include file $ifile");
    }

    sub define
    {
        my ($self, $name, $value) = @_;

        $self->{defines}->{$name} = { value => $value };
    }

    # sub _eval is defined at the start of the file, to provide a clean lexical
    # environment

    sub emit_line_marker
    {
        my $self = shift;

        print { $self->{output} } qq{`line },
                                  $self->{fh}->input_line_number,
                                  qq{ "}, $self->{filename}, qq{" 0\n};
    }

    sub expand_macros
    {
        my $self = shift;

        # !!! detect recursion
        while ($_[0] =~ /\G\W*\b(\w+)\b/gc) {
            if (exists ($self->{defines}->{$1})) {
                my $start = $-[1];
                my $end = $+[1];

                my $name = $1;
                my $d = $self->{defines}->{$name};
                if (!$d->{args}) {
                    &VP3::debug && print STDERR "expand $name as $d->{value}\n";
                    substr ($_[0], $start, $end - $start) = $d->{value};
                } else {
                    my (@supplied_args, $va_args);

                    unless ($_[0] =~ /\G\s*\(([^\(\)]*)\)/gc) {
                        VP3::error ("Expected arguments for macro $name");
                        next;
                    }

                    $end = $+[0];

                    @supplied_args = split (',', $1, -1);

                    if ($d->{args}->[-1] eq "...") {
                        $va_args = join (",", @supplied_args[$#{$d->{args}} .. $#supplied_args]);
                        $#supplied_args = $#{$d->{args}} - 1;
                    }

                    my $expansion = $d->{value};

                    if (defined ($va_args)) {
                        $expansion =~ s/\b__VA_ARGS__\b/$va_args/g;
                    }

                    # @supplied_args is one shorter than @{$d->{args}} in the
                    # $va_args case.
                    for (my $i = 0; $i <= $#supplied_args; $i++) {
                        my $arg = $d->{args}->[$i];
                        $expansion =~ s/\b$arg\b/$supplied_args[$i]/g;
                    }

                    $expansion =~ s/##//g; # token paste
                    $expansion =~ s/_&nl&_/\n/g;

                    &VP3::debug && print STDERR "expand $name (" . join (",", @supplied_args) . ") as $expansion\n";
                    substr ($_[0], $start, $end - $start) = $expansion;

                }

                pos ($_[0]) = $start;
            }
        }
    }

    sub getline
    {
        my $self = shift;

        while (1) {
            my $tmp = $self->{fh}->getline;

            return $tmp if defined ($tmp);

            if (@{$self->{stack}}) {
                $self->{fh} = pop @{$self->{stack}};
                next;
            } else {
                return undef;
            }
        }

    }

    sub process
    {
        my ($self, $args) = @_;

        $self->{filename} = $args->{input};

        $self->{fh} = IO::File->new ($self->{filename}, "r")
            or die "Couldn't open `$self->{filename}': $!";

        $self->{output} = IO::File->new ($args->{output}, "w")
            or die "Couldn't open `$args->{output}': $!";

        my $line = "";
        my $emit_line_marker = 1;

        while (1) {

            if ($line eq "" || $line =~ /\G\z/) {
                $line = $self->getline;
                last unless defined ($line);
            }

            if ($emit_line_marker) {
                $self->emit_line_marker;
                $emit_line_marker = 0;
            }

            if ($self->{state} == ST_COMMENT && $line =~ m/$re_comment_body/gc) {

                if ($1) {
                    # comment ends
                    print { $self->{output} } $1;
                    $self->{state} = ST_DEFAULT;
                    next;
                } elsif ($2) {
                    # comment continues
                    print { $self->{output} } $2;
                    next;
                } else {
                    VP3::fatal ("in preprocessor, ST_COMMENT");
                }

            } elsif ($self->{state} == ST_PERL) {

                $line =~ m/$re_directive/gc;
                my ($indent, $directive, $rest) = ($1, $2, $3);

                if (!defined ($directive) || $directive ne "perl_end") {
                    $self->expand_macros ($line);
                    $self->{perl_text} .= $line;
                    $line = "";
                    next;
                } else {
                    $self->_eval ($self->{perl_text});
                    if ($@) {
                        chomp $@;
                        VP3::error ("in perl section starting on line " . $self->{perl_start} . ":",
                                    $@);
                    }
                    $self->{perl_text} = "";
                    $self->{state} = ST_DEFAULT;
                    $self->{perl_start} = undef;
                    $line = "";
                    $emit_line_marker = 1;
                    next;
                }

            } elsif ($self->{state} == ST_DEFAULT && $line =~ m/$re_directive/gc) {

                my $more = "";

                while ($line =~ /\\\n$/ && defined ($more)) {
                    $more = $self->getline;
                    $line .= $more if defined ($more);
                }

                # Re-match after reading continuation lines
                $line =~ m/$re_directive/;
                my ($indent, $directive, $rest) = ($1, $2, $3);

                if ($directive eq "include") {
                    if ($rest =~ /^"(.+)"\s*$/) {
                        $self->include ($1);
                    } else {
                        VP3::error ("Illegal \@include directive");
                    }

                    next;
                } elsif ($directive eq "depend") {
                    if ($rest =~ /^"(.+)"\s*$/) {
                        # Note that $self->depend is not purely a
                        # directive-implementing function
                        $self->depend ("inc", $1);
                    } else {
                        VP3::error ("Illegal \@depend directive");
                    }

                    next;
                } elsif ($directive eq "ifdef") {
                    if ($rest =~ /^(\w+)\s*$/) {
                        my $cond = exists ($self->{defines}->{$1});

                        $self->{enabled} = $self->{conditionals}->ifdef ($cond);

                        print { $self->{output} } ("\n");
                    } else {
                        VP3::error ("Illegal \@ifdef directive");
                    }

                    next;
                } elsif ($directive eq "ifndef") {
                    if ($rest =~ /^(\w+)\s*$/) {
                        my $cond = !exists ($self->{defines}->{$1});

                        $self->{enabled} = $self->{conditionals}->ifdef ($cond);

                        print { $self->{output} } ("\n");
                    } else {
                        VP3::error ("Illegal \@ifndef directive");
                    }

                    next;
                } elsif ($directive eq "elsif" && $rest =~ /^(\w+)\s*$/) {
                    # Only "@elsif FOO" handled here (i.e., else ifdef FOO).
                    # Otherwise the line is macro-expanded before the directive is
                    # processed.
                    my $cond = exists ($self->{defines}->{$1});

                    $self->{enabled} = $self->{conditionals}->elsif ($cond);

                    print { $self->{output} } ("\n");
                    $emit_line_marker = 1;
                    next;
                } elsif ($directive eq "else") {
                    $self->{enabled} = $self->{conditionals}->else;
                    print { $self->{output} } ("\n");
                    $emit_line_marker = 1;
                    next;
                } elsif ($directive eq "endif") {
                    $self->{enabled} = $self->{conditionals}->endif;
                    print { $self->{output} } ("\n");
                    $emit_line_marker = 1;
                    next;
                } elsif ($directive eq "define") {
                    unless ($rest =~ /^(\w+)\s(.*)$/) {
                        VP3::error ("Illegal \@define directive: $rest");
                        next;
                    }

                    my ($name, $value) = ($1, $2);
                    if (exists ($self->{defines}->{$name})) {
                        # !!! give location
                        VP3::warning ("Redefinition of $name");
                    }

                    &VP3::debug && print STDERR "define $name as $value\n";

                    $self->{defines}->{$name} = { value => $value };

                    print { $self->{output} } ("\n");
                    next;
                } elsif ($directive eq "macro") {
                    $rest =~ /^(\w+)\(([\w,]+(?:\.\.\.)?)\)\s(.*)$/ or do { VP3::error ("Illegal \@macro directive: $rest"); next };
                    my ($name, $args, $value) = ($1, $2, $3);

                    if (exists ($self->{defines}->{$name})) {
                        # !!! give location
                        VP3::warning ("Redefinition of $name");
                    }

                    &VP3::debug && print STDERR "define $name as $value\n";

                    $self->{defines}->{$name} = {
                        value => $value,
                        args => [ split (',', $args) ],
                    };

                    print { $self->{output} } ("\n");
                    next;
                } elsif ($directive eq "perl_begin") {
                    $rest =~ /^$/ or VP3::error ("Illegal \@perl_begin directive");
                    $self->{state} = ST_PERL;
                    $self->{perl_start} = $self->{fh}->input_line_number;
                    next;
                } elsif ($directive eq "if") {
                    $self->expand_macros ($rest);

                    my $cond = $self->_eval ($rest);

                    if ($@) {
                        chomp $@;
                        VP3::error ("while evaluating conditional:",
                                    $@);
                        $cond = 0;
                    }

                    $self->{enabled} = $self->{conditionals}->ifdef ($cond);

                    print { $self->{output} } ("\n");
                    next;
                } elsif ($directive eq "elsif") {
                    $self->expand_macros ($rest);

                    my $cond = $self->_eval ($rest);

                    if ($@) {
                        chomp $@;
                        VP3::error ("while evaluating conditional:",
                                    $@);
                        $cond = 0;
                    }

                    $self->{enabled} = $self->{conditionals}->elsif ($cond);

                    print { $self->{output} } ("\n");
                    next;
                } elsif (exists ($self->{pkg_stash}->{$directive}) && defined (*{$self->{pkg_stash}->{$directive}}{CODE})) {
                    $self->expand_macros ($rest);

                    eval "package $self->{pkg_name}; $directive (\$rest)";

                    if ($@) {
                        chomp $@;
                        VP3::error ("while expanding directive:",
                                    $@);
                    }

                    $emit_line_marker = 1;
                    next;
                } elsif (!exists ($defer_directives{$directive})) {
                    VP3::error ("unknown directive $directive");
                    next;
                } else {
                    $self->expand_macros ($rest);
                    print { $self->{output} } $line;
                }

            } else {

                $line =~ m/$re_default/gc;

                my $lead_text;

                if ($self->{enabled}) {
                    $lead_text = $1;
                    $self->expand_macros ($lead_text);
                    print { $self->{output} } $lead_text;
                }

                if ($2) {
                    # Start of multiline comment

                    print { $self->{output} } $2;
                    $self->{state} = ST_COMMENT;
                    next;
                } elsif ($3) {
                    # Single-line comment

                    print { $self->{output} } $3;
                    next;
                } elsif ($4) {
                    # String

                    if ($line =~ m/\G([^"]*)"/gc) {

                        if ($self->{enabled}) {
                            print { $self->{output} } q{"}, $1, q{"};
                        }

                        next;

                    } else {
                        VP3::error ("Syntax error, unterminated string"); # !!! better error

                        # Assume the string was to terminate at EOL

                        if ($self->{enabled}) {
                            print { $self->{output} } q{"}, $line;
                        }

                        $line = "";
                        next;
                    }
                } elsif ($5) {
                    # Escaped identifier

                    if ($self->{enabled}) {
                        print { $self->{output} } $5;
                    }
                } elsif ($6) {
                    # Reached end-of-line.

                    print { $self->{output} } $6;
                }

            }

        }

        $self->{fh}->close;
        $self->{output}->close;

        return !$VP3::error_count ? 1 : undef;
    }

} # package VP3::Preprocessor::standard

{
    package VP3::Preprocessor::ep3;

    use File::Temp qw();

    for (qw(Module Ports Regs Wires Vector Input Output Waive Unparsed Instance)) {
        # In depends mode, EP3 closes the default filehandle.
        no warnings 'unopened';
        eval "sub Text::EP3::$_ { print \$_[1] }";
    }

    VP3::UserFunctions::install ("Text::EP3");

    sub new
    {
        require Text::EP3;

        my ($class, $vp3) = @_;
        my $self = {
            ep3 => Text::EP3->new,
            defines => [ ],
            vp3 => $vp3,
        };
        bless $self, $class;
    }

    sub depends_mode
    {
        $_[0]->{depends_mode} = $_[1];
    }

    sub depends
    {
        return map [ "inc", $_ ], @{$_[0]->{depends}};
    }

    sub includes { $_[0]->{ep3}->ep3_includes (@_[1..$#_]); }

    sub define
    {
        my ($self, $key, $value) = @_;

        # EP3 chokes if there's no value (no equals sign) when defining things
        # via ep3_defines, so always include the equals sign.
        push @{$self->{defines}}, join ("=", $key, defined ($value) ? $value : "");
    }

    sub process
    {
        my ($self, $args) = @_;

        no warnings 'once';
        local $Text::EP3::vp3 = $self->{vp3};

        if ($self->{depends_mode}) {
            my $depends_output = File::Temp->new;

            $self->{ep3}->ep3_gen_depend_list (1);
            $self->{ep3}->ep3_output_file ($depends_output->filename);
            @{$self->{ep3}->{Defines}} = @{$self->{defines}};
            $self->{ep3}->ep3_defines;
            my $result = eval { $self->{ep3}->ep3_process ($args->{input}); };

            if (!defined ($result)) {
                chomp $@;
                VP3::error ("EP3 error: $@");
            }

            # Need to force ep3 to flush and close the file so we get all the
            # dependencies
            $self->{ep3}->ep3_output_file ("STDOUT");

            open (my $fh, "<", $depends_output)
                or VP3::error_fatal ("Failed to open ep3 depends output: $!");

            chomp (@{$self->{depends}} = <$fh>);

            if (!defined ($result)) {
                return undef;
            }

            $self->{ep3}->ep3_reset;
            $self->{ep3}->ep3_gen_depend_list (undef);
        }

        $self->{ep3}->ep3_output_file ($args->{output});
        @{$self->{ep3}->{Defines}} = @{$self->{defines}};
        $self->{ep3}->ep3_defines;
        my $result = eval { $self->{ep3}->ep3_process ($args->{input}); };

        if (!defined ($result)) {
            chomp $@;
            VP3::error ("EP3 error: $@");
            return undef;
        }

        # Close the output
        $self->{ep3}->ep3_output_file ("STDOUT");

        return 1;
    }

} # package VP3::Preprocessor::ep3

{

package VP3;

use VP3::Parser;
use Data::Dumper;
use IO::Handle;
use IO::File;
use IO::Seekable; # For SEEK_SET
use Getopt::Long;
use Carp qw(carp cluck croak confess);
use File::Temp qw();
use File::Copy qw();
use File::Spec;
use Class::Struct;
use Scalar::Util qw(blessed);

BEGIN {
    struct (
        'VP3::ModuleCacheEntry' => [
            # Parse tree for the module
            module => '$',

            # True if the module was found incidentally, e.g. while looking
            # for a different module. Opportunistically cached modules have
            # not had their dependencies recorded and might not be found if
            # they were independently sought using only library specifications
            # # (-v and -y) from the command line.
            is_opp => '$',

            # Source file from which we parsed the module. Unset if the module
            # is from the current file.
            source_file => '$',

            # List of dependencies. Unset if the module is from the current
            # file.
            depends => '@',
        ]
    );
}

our ($debug);
our ($library_dirs)  = [ ];
our ($library_files) = [ ];

# This string is written at the start of generated files. In certain cases, we
# check for this string before overwriting a file, so be careful adding
# versions or timestamps.
our ($signature) = "// Generated by vp3";

# Error infrastructure

our ($warning_count) = 0;
our ($error_count)   = 0;

sub warning {
    $warning_count++;

    my $msg = "WARNING: " . join ("\n         ", @_) . "\n";

    if ($debug) {
        my ($package, $filename, $line) = caller;
        $msg .= "         raised at $filename line $line\n";
    }

    warn $msg;
}

sub error {
    $error_count++;

    my $msg = "ERROR: " . join ("\n       ", @_) . "\n";

    if ($debug) {
        cluck $msg;
    } else {
        warn $msg;
    }
}

sub error_fatal {
    my $msg = "ERROR (fatal): " . join ("\n               ", @_) . "\n";

    if ($debug) {
        confess $msg;
    } else {
        die $msg;
    }
}

# Calling this "error_internal" would be more appropriate
sub fatal {
    my $msg = "INTERNAL ERROR: " . join ("\n                ", @_) . "\n";
    confess $msg;
}

##

# Work around for bug in interaction between File::Copy and File::Temp.
# File::Copy chokes on File::Temp objects because they overload
# stringify but not eq. Believe this is fixed in newer perls.

sub file_copy
{
    my ($a, $b) = @_;

    if (blessed ($a) && $a->isa ("File::Temp")) {
        $a = IO::Handle->new_from_fd ($a->fileno, "r")
            or VP3::error_fatal ("new_from_fd failed: $!");
    }

    if (blessed ($b) && $b->isa ("File::Temp")) {
        $b = IO::Handle->new_from_fd ($b->fileno, "w")
            or VP3::error_fatal ("new_from_fd failed: $!");
    }

    File::Copy::copy ($a, $b);
}

##

sub depend
{
    push @{$_[0]->{depends}}, [ @_[1..$#_] ];
}

##

sub new
{
    my $class = shift;
    my $self = {
        preprocessor    => "standard",
        module_cache    => { },
        output          => "-",
        v_defines       => [ ],
        pp_defines      => [ ],
        v_includes      => [ "." ],
        pp_includes     => [ "." ],
    };

    GetOptions (
        "o=s"           => \$self->{output},
        "depends"       => \$self->{depends_mode},
        "p=s"           => \$self->{preprocessor},
        "debug"         => \$debug,
        "vdefine=s\@"   => $self->{v_defines},
        "define=s\@"    => $self->{pp_defines},
        "vinclude=s\@"  => $self->{v_includes},
        "include=s\@"   => $self->{pp_includes},
        "v=s\@"         => $library_files,
        "y=s\@"         => $library_dirs,
        "w"             => \$self->{warnings_as_errors},
    ) or VP3::error ("Invalid command line options");

    if (@ARGV != 1) {
        die "Usage: vp3 [<options>] <input_file>\n";
    }

    $self->{input}    = $ARGV[0];
    $self->{basename} = $self->{input};
    $self->{basename} =~ s/\..*//;
    $self->{pass1out} = File::Temp->new;

    if ($self->{output} ne "-" && $self->{output} eq $self->{input}) {
        VP3::error_fatal ("will not overwrite input file with output");
    }

    bless $self, $class;
}

sub debug { $debug }

sub parse
{
    my ($self, $fh, $name, $basename, $depend_cb, $error_ref) = @_;

    my $p = VP3::Parser->new;
    $p->YYData->{lexer} = VP3::Lexer->new;
    $p->YYData->{lexer}->depend_cb ($depend_cb);
    $p->YYData->{lexer}->input ($fh, $name);

    for (@{$self->{v_defines}}) {
        my ($name, $value) = split ('=', $_);
        defined ($value) or $value = "";

        $p->YYData->{lexer}->define ($name, $value);
    }

    for (@{$self->{v_includes}}) {
        $p->YYData->{lexer}->include_path ($_);
    }

    $p->YYData->{basename} = $basename;

    $p->YYParse (
                 yylex   => sub { $_[0]->YYData->{lexer}->lex (@_[1..$#_]) },
                 yyerror => \&VP3::Parser::default_yyerror,
                 #yydebug => 0xF,
                )
        or ($$error_ref = $p->YYData->{error}, undef);
}

sub write_debug_file
{

    my ($self, $desc, $output) = @_;

    if ($self->{depends_mode}) {
        # Don't generate debug files in depends mode.
        return;
    }

    my $save_file = $self->{input} . ".debug";
    my $fh;

    if (-f $save_file) {
        # File already exists. Overwrite only if it looks like previous VP3 output.

        unless ($fh = IO::File->new ($save_file, "r+")) {
            VP3::error ("couldn't open $save_file: $!");
            print STDERR "${desc} not saved to $save_file due to error\n";
            return;
        }

        my $line = $fh->getline;
        if (!$line || $line ne "$signature\n") {
            print STDERR "${desc} not saved because $save_file already exists\n";
            return;
        }

        unless ($fh->truncate (0) && $fh->seek (0, SEEK_SET)) {
            VP3::error ("error truncating $save_file");
            print STDERR "${desc} not saved to $save_file due to error\n";
            return;
        }
    } else {
        # File doesn't exist.

        unless ($fh = IO::File->new ($save_file, O_WRONLY | O_CREAT | O_EXCL)) {
            VP3::error ("couldn't open $save_file: $!");
            print STDERR "${desc} not saved to $save_file due to error\n";
            return;
        }
    }

    file_copy ($output, $fh);

    print STDERR "${desc} has been saved in $save_file\n";

}

sub parse_pass1out
{
    my ($self) = @_;
    my $error;
    my $vdb;

    {
        # Insert the signature line before we parse, so line numbers in error
        # messages will match up
        my $tmp = File::Temp->new;
        $tmp->print ("$signature\n\n");
        $tmp->flush;

        file_copy ($self->{pass1out}->filename, $tmp);
        $tmp->flush;
        $self->{pass1out} = $tmp;
    }

    my $fh = IO::File->new ($self->{pass1out}->filename, "r")
        or VP3::error_fatal ("can't open " . $self->{pass1out}->filename . " for reading: $!");

    my $depend_cb = sub {
        $self->depend (@_);
    };

    $vdb = $self->{vp3}{vdb} = $self->parse ($fh,
                                             $self->{input},
                                             $self->{basename},
                                             $depend_cb,
                                             \$error);

    unless ($vdb) {
        VP3::error ($error);
        $self->write_debug_file ("Preprocessor output", $self->{pass1out}->filename);
        return undef;
    }

    return 1;
}

sub analyze
{
    my ($self) = @_;
    my $vdb = $self->{vp3}{vdb};
    my $conn_db;

    #print STDERR "*** BEGIN analyze $self->{pass1out} parse tree ***\n";
    #print STDERR Dumper ($self->{vp3}{vdb});
    #print STDERR "*** END analyze $self->{pass1out} parse tree ***\n";

    my %instantiations;

    # Collect the list of all instantiations in each module
    for ($vdb->modules) {
        my $module = $_->module_identifier;

        if (exists ($instantiations{$module})) {
            VP3::error ("Multiple definitions found for module $module");
            next;
        }

        $instantiations{$module} = [ ];

        # !!! does not support generate blocks
        for (@{$_->module_items->children}) {
            #print "examining module_item, type ", $_->type, "\n";
            if ($_->typeis ("vp3_instance_directive")) {
                push @{$instantiations{$module}}, $_->module;
            } elsif ($_->typeis ("module_instantiation")) {
                push @{$instantiations{$module}}, $_->module_identifier->emit_self;
            }
        }
    }

    #print Dumper (\%instantiations);

    # Remove modules that are not defined in this file, we don't care about them
    for my $modlist (values %instantiations) {
        @$modlist = grep { exists $instantiations{$_} } @$modlist;
    }

    while (%instantiations) {
        #print Dumper (\%instantiations);

        my @leaves = grep { 0 == scalar @{$instantiations{$_}} } keys %instantiations;

        if (@leaves == 0) {
            VP3::error ("Circular dependency detected");
            last;
        }

        for my $modname (@leaves) {
            my $modref = $vdb->module_ref ($modname);
            my $validate = !($$modref->typeis ("vp3_module_declaration") && $$modref->vp3_module_directive->opt_none);
            my $xlate;

            # Expand @Instance
            $xlate = VP3::Expander->new ($self);
            $$modref = $xlate->visit ($$modref);

            $debug && print STDERR "Analyzing ", $modname, "\n";
            $conn_db = VP3::ConnectivityAnalyzer::analyze ($self, $$modref);
            $self->{vp3}{connectivity}{$modname} = $conn_db;

            #print STDERR "*** BEGIN analyze connectivity DB dump ***\n";
            #print STDERR Dumper ($conn_db);
            #print STDERR "*** END analyze connectivity DB dump ***\n";

            # Expand directives other than @Instance
            $xlate = VP3::Translator->new ($self);
            $$modref = $xlate->visit ($$modref);

            #print STDERR "*** BEGIN translated parse tree ***\n";
            #print STDERR Dumper ($$modref);
            #print STDERR "*** END translated parse tree ***\n";

            if ($validate) {
                $debug && print STDERR "Validating connectivity in ", $modname, "\n";
                $self->{vp3}{connectivity}{$modname}->validate;
            } else {
                $debug && print STDERR "Not validating connectivity in module generated with -none\n";
            }

            #print Dumper ($modref);

            # Save module information in the cache (in case there are multiple modules in the file)
            $self->{module_cache}->{$modname} = VP3::ModuleCacheEntry->new (
                module  => $$modref,
                is_opp  => 0,
            );

            # The current module is now considered a leaf, i.e. now that it is
            # processed we can work on any modules that instantiate it.
            delete $instantiations{$modname};
        }

        for my $modlist (values %instantiations) {
            @$modlist = grep { exists $instantiations{$_} } @$modlist;
        }
    }

    if ($self->{warnings_as_errors} && $warning_count) {
        VP3::error ("warnings being treated as errors");
    }

    if ($error_count) {
        return undef;
    }

    1;
}

# Write the output verilog to a temp file, and return the temp file object.

sub generate_verilog
{
    my $self = $_[0];
    my $output;

    my $emit = sub {
        no warnings 'recursion';

        my ($self, $target) = @_;

        if (!@{$target->children}) {
            $output .= $target->emit (&VP3::ParseTree::VISIBLE_ONLY);
        } else {
            goto $self->can ("visit_children");
        }
    };

    my $v = VP3::ParseTreeVisitor->new ($emit);
    $v->visit ($self->{vp3}{vdb});

    my $fh = File::Temp->new or VP3::error_fatal ("can't create temporary file");

    $fh->print ($output);
    $fh->flush;

    $fh;
}

sub output_verilog
{

    my $self = $_[0];
    my $tmp = $_[1];
    my $fh;

    if ($self->{output} ne "-") {
        $fh = IO::File->new ($self->{output}, "w")
            or VP3::error_fatal ("can't open `" . $self->{output} . "' for writing: $!");
    } else {
        $fh = *STDOUT{IO};
    }

    file_copy ($tmp, $fh);

}

sub output_depends
{

    my $self = $_[0];

    my $fh;

    if ($self->{output} ne "-") {
        $fh = IO::File->new ($self->{output}, "w")
            or VP3::error_fatal ("can't open `$self->{output}' for writing: $!");
    } else {
        $fh = *STDOUT{IO};
    }

    my %printed;

    for (@{$self->{depends}}) {
        my $tag = $_->[0] . ":" . $_->[1];
        next if $printed{$tag}++;
        print $fh "$_->[0] $_->[1]\n";
    }

}

# Helpers for ports(). Not geared for general use.

use Cwd qw();

sub find_module_in_cache
{
    my ($self, $module, $file) = @_;

    return undef unless (my $cache_entry = $self->{module_cache}->{$module});

    my $cache_source_file = Cwd::abs_path ($cache_entry->source_file);
    my $current_source_file = Cwd::abs_path ($file);

    return undef if ($cache_source_file ne $current_source_file);

    $debug && print STDERR "using cached description of $module (after search)\n";

    return $cache_entry;
}

sub add_module_to_cache
{
    my ($self, $module, $is_opp, $file, $depends) = @_;

    my $name = $module->module_identifier;
    my $cache = $self->{module_cache};

    if (!$cache->{$name}) {
        $debug && print STDERR "Adding $name to module cache\n";

        $cache->{$name} = VP3::ModuleCacheEntry->new (
            module      => $module,
            is_opp      => $is_opp,
            source_file => $file,
            depends     => $depends,
        );

        return 1;
    } else {
        my $cache_source_file = Cwd::abs_path ($cache->{$name}->source_file);
        my $current_source_file = Cwd::abs_path ($file);

        if ($cache_source_file ne $current_source_file) {
            VP3::warning ("module `$name' has been read from both " .
                          "`$cache_source_file' and `$current_source_file'");
        } elsif ($debug) {
            print STDERR "module `$name' should have been retrieved from cache. possible bug.\n";
        }

        return undef;
    }
}

# This function is often called twice for instantiated modules, once when
# expanding the @Instance directive, and again when doing connectivity
# analysis. For @Instance, the file to read may be specified manually with
# -file, but that information doesn't propagate to the connectivity analyzer.

sub ports
{

    my ($self, $module, @search_files) = @_;

    my $cache = $self->{module_cache};

    if ($cache->{$module} && !$cache->{$module}->is_opp) {
        $debug && print STDERR "using cached description of module $module (search bypassed)\n";
        return $cache->{$module}->module->ports;
    }

    if (@search_files) {
        @search_files = map [ "vlib", $_ ], @search_files;
    } else {
        @search_files = map [ "vmod", File::Spec->catfile ($_, "${module}.v") ], @$library_dirs;
        push @search_files, map [ "vlib", $_ ], @$library_files;
    }

    # !!! should give a better error message
    unless (@search_files) {
        VP3::warning ("No files known in which to look for `$module'");
        return undef;
    }

    for (@search_files) {
        my ($dep_type, $file) = @$_;
        my $fh;

        next unless -f $file;

        unless ($fh = IO::File->new ($file)) {
            VP3::warning ("while searching for $module, couldn't open $file: $!");
            next;
        }

        # If we happened to parse this module previously, record the
        # dependencies, and then return the cached copy.
        if (my $cached_module = $self->find_module_in_cache ($module, $file)) {
            if ($cached_module->is_opp) {
                $self->depend ($dep_type, $dep_type eq "vlib" ? $file : $module);
                $self->depend (@$_) for @{$cached_module->depends};
            }
            return $cached_module->module->ports;
        }

        $debug && print STDERR "Looking for ports of $module in $file\n";

        # Collect dependencies in this list, but don't record them until we
        # know we're going to use the module.
        my @depends;
        my $depend_cb = sub {
            push @depends, [ @_ ];
        };

        my $error;
        my $vroot = $self->parse ($fh, $file, undef, $depend_cb, \$error);

        if (!$vroot) {
            VP3::warning ("While searching for $module, couldn't parse $file:\n$error");
            next;
        }

        my $result;

        for ($vroot->modules) {
            my $opp;

            if ($_->module_identifier eq $module) {
                $opp = 0;
                $result = $_;
            } else {
                $opp = 1;
            }

            $self->add_module_to_cache ($_, $opp, $file, \@depends);
        }

        if (!$result) {
            $debug && print STDERR "Module $module not found in $file\n";
            next;
        }

        # Record dependencies, since we're actually going to use the module.
        $self->depend ($dep_type, $dep_type eq "vlib" ? $file : $module);
        $self->depend (@$_) for @depends;

        #if ($debug) {
        #    print STDERR "*** BEGIN $file parse tree ***\n";
        #    print STDERR Dumper ($vroot);
        #    print STDERR "*** END $file parse tree ***\n";
        #}

        # If we got here, we found the module defn, so we're done
        return $result->ports;
    }

    VP3::error ("Couldn't find definition for $module");

    # If there are any library directories where we could read the module from
    # if it existed, produce a dependency record.
    if (grep { $_->[0] eq "vmod" } @search_files) {
        $self->depend ("vmod", $module);
    }

    return undef;

}

sub process
{

    my ($self) = @_;

    # First pass - preprocessor

    my $pp_class = "VP3::Preprocessor::" . $self->{preprocessor};
    $pp_class->can ("new") or VP3::error_fatal ("unknown preprocessor " . $self->{preprocessor});

    my $pp = $pp_class->new ($self) or die "Failed to create preprocessor object";

    $pp->depends_mode ($self->{depends_mode});
    $pp->includes (@{$self->{pp_includes}});

    for (@{$self->{pp_defines}}) {
        my ($name, $value) = split ('=', $_);
        # $value is undefined if there was no =, that's what we want
        $pp->define ($name, $value);
    }

    my $pp_result = $pp->process ({
        input => $self->{input},
        output => $self->{pass1out}->filename,
    });

    if ($self->{depends_mode}) {
        $self->depend (@$_) for $pp->depends;
    }

    if (!$pp_result) {
        if ($self->{depends_mode}) {
            $self->output_depends;
        }
        return undef;
    }

    # Verilog parse

    my $parse_result = $self->parse_pass1out;

    if (!$parse_result) {
        if ($self->{depends_mode}) {
            $self->output_depends;
        }
        return undef;
    }

    # Second pass - verilog analysis and generation

    my $analyze_result = $self->analyze;

    if ($self->{depends_mode}) {
        $self->output_depends;
    } else {
        my $tmp = $self->generate_verilog;

        if ($analyze_result) {
            $self->output_verilog ($tmp->filename);
        } else {
            $self->write_debug_file ("Expanded Verilog", $tmp->filename);
        }
    }

    return $analyze_result

}

} # package VP3

########

# main

#use VP3;

my $v = VP3->new (@ARGV);

my $r = $v->process;

exit ($r ? 0 : 1);

# vim: sts=4 sw=4 et
